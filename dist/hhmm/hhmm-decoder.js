'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder <br />
 * Loads a model trained by the XMM library and processes an input stream of float vectors in real-time.
 * If the model was trained for regression, outputs an estimation of the associated process.
 * @class
 */

var HhmmDecoder = function () {

  /**
   * @param {Number} [windowSize=1] - Size of the likelihood smoothing window.
   */
  function HhmmDecoder() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * Size of the likelihood smoothing window.
     * @type {number}
     * @private
     */
    this._likelihoodWindow = windowSize;

    /**
     * The model, as generated by XMM from a training data set.
     * @type {Object}
     * @private
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter.
     * @type {Object}
     * @private
     */
    this._modelResults = undefined;
  }

  /**
   * Callback handling estimation results.
   * @callback hhmmResultsCallback
   * @param {string} err - Description of a potential error.
   * @param {hhmmResults} res - Object holding the estimation results.
   */

  /**
   * Results of the filtering process.
   * @typedef hhmmResults
   * @type {Object}
   * @name hhmmResults
   * @property {String} likeliest - The likeliest model's label.
   * @property {Number} likeliestIndex - The likeliest model's index
   * @property {Array.number} likelihoods - The array of all models' smoothed normalized likelihoods.
   * @property {Array.number} timeProgressions - The array of all models' normalized time progressions.
   * @property {Array.Array.number} alphas - The array of all models' states likelihoods array.
   * @property {?Array.number} outputValues - If the model was trained with regression, the estimated float vector output.
   * @property {?Array.number} outputCovariance - If the model was trained with regression, the output covariance matrix.
   */

  /**
   * The decoding function.
   * @param {Array.number} observation - An input float vector to be estimated.
   * @param {hhmmResultsCallback} [resultsCallback=null] - The callback handling the estimation results.
   * @returns {hhmmResults}
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation) {
      var resultsCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var err = null;
      var res = null;

      if (!this._model) {
        err = 'no model loaded yet';
      } else {
        try {
          console.log('filter !');
          hhmmUtils.hhmmFilter(observation, this._model, this._modelResults);

          // create results object from relevant modelResults values :
          var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: likeliest,
            likeliestIndex: this._modelResults.likeliest,
            likelihoods: likelihoods,
            timeProgressions: new Array(this._model.models.length),
            alphas: new Array(this._model.models.length)
          };

          for (var i = 0; i < this._model.models.length; i++) {
            res.timeProgressions[i] = this._modelResults.singleClassHmmModelResults[i].progress;
            if (this._model.configuration.default_parameters.hierarchical) {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha_h[0];
            } else {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha[0];
            }
          }

          if (this._model.shared_parameters.bimodal) {
            res['outputValues'] = this._modelResults.output_values.slice(0);
            res['outputCovariance'] = this._modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      if (resultsCallback) {
        resultsCallback(err, res);
      }
      return res;
    }

    /**
     * Resets the intermediate results of the estimation (shortcut for reloading the model).
     */

  }, {
    key: 'reset',
    value: function reset() {
      if (this._model) {
        this._setModel(this._model);
      }
    }

    //========================== GETTERS / SETTERS =============================//

    /***
     * Likelihood smoothing window size.
     * @type {Number}
     */
    // get likelihoodWindow() {
    //   return this._likelihoodWindow;
    // }

    // set likelihoodWindow(newWindowSize) {
    //   this._likelihoodWindow = newWindowSize;
    //   this._updateLikelihoodWindow();
    // }

    /**
     * Get the likelihood smoothing window size.
     * @returns {Number}
     */

  }, {
    key: 'getLikelihoodWindow',
    value: function getLikelihoodWindow() {
      return this._likelihoodWindow;
    }

    /**
     * Set the likelihood smoothing window size.
     * @param {Number} newWindowSize - the new window size.
     */

  }, {
    key: 'setLikelihoodWindow',
    value: function setLikelihoodWindow(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      this._updateLikelihoodWindow();
    }

    /** @private */

  }, {
    key: '_updateLikelihoodWindow',
    value: function _updateLikelihoodWindow() {
      if (this._model === undefined) return;

      var res = this._modelResults.singleClassHmmModelResults;

      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);

        for (var j = 0; j < this._likelihoodWindow; j++) {
          res[i].likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    /**
     * A valid XMM Hierarchical HMM model
     * @typedef xmmHhmmModel
     * @type {Object}
     * @name xmmHhmmModel
     * @property {String} TODO - LIST REAL HHMM MODEL PROPERTIES HERE
     */

    /***
     * The model generated by XMM.
     * It is mandatory for the class to have a model in order to do its job.
     * @type {xmmHhmmModel}
     */
    // get model() {
    //   return this.getModel();
    // }

    // set model(model) {
    //   this.setModel(model);
    // }

    /**
     * Get the actual XMM Hierarchical HMM model.
     * @returns {xmmHhmmModel}
     */

  }, {
    key: 'getModel',
    value: function getModel() {
      if (this._model) {
        return JSON.parse((0, _stringify2.default)(this._model));
      }
      return undefined;
    }

    /**
     * Set the actual XMM Hierarchical HMM model.
     * @param {xmmHhmmModel} model
     */

  }, {
    key: 'setModel',
    value: function setModel(model) {
      this._setModel(model);
    }

    /** @private */

  }, {
    key: '_setModel',
    value: function _setModel(model) {

      this._model = undefined;
      this._modelResults = undefined;

      if (!model) return;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          //---- full
          outCovarSize = dimOut * dimOut;
        } else {
          //------------------------------------------------------ diagonal
          outCovarSize = dimOut;
        }

        this._modelResults.output_covariance = new Array(outCovarSize);

        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {
          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var nstates = m.models[_i2].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          var likelihood_buffer = new Array(this._likelihoodWindow);
          for (var _j2 = 0; _j2 < this._likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            // prior: new Array(nstates),
            // transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // aka states
          };

          hmmRes.output_values = this._modelResults.output_values.slice(0);
          hmmRes.output_covariance = this._modelResults.output_covariance.slice(0);

          // add HMM states (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this._model.models[_i2].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this._modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }
    }

    /***
     * Currently estimated likeliest label.
     * @readonly
     * @type {String}
     */
    // get likeliestLabel() {
    //   return this.getLikeliestLabel();
    // }

    /**
     * Get the currently estimated likeliest label.
     * @returns {String}
     */

  }, {
    key: 'getLikeliestLabel',
    value: function getLikeliestLabel() {
      if (this._modelResults) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }

    /***
     * Number of classes contained in the model.
     * @readonly
     * @type {Number}
     */
    // get nbClasses() {
    //   return this.getNumberOfClasses();
    // }

    /**
     * Get the total number of classes the model was trained with.
     * @returns {Number}
     */

  }, {
    key: 'getNumberOfClasses',
    value: function getNumberOfClasses() {
      if (this._model) {
        return this._model.models.length;
      }
      return 0;
    }

    /***
     * Size of the regression vector if model is bimodal.
     * @readonly
     * @type {Number}
     */
    // get regressionSize() {
    //   return this.getRegressionVectorSize();
    // }

    /**
     * Get the output dimension of the model (size of a regression vector).
     * @returns {Number}
     */

  }, {
    key: 'getRegressionVectorSize',
    value: function getRegressionVectorSize() {
      if (this._model) {
        var params = this._model.shared_parameters;
        return params['bimodal'] ? params['dimension'] - params['dimension_input'] : 0;
      }
      return 0;
    }
  }]);
  return HhmmDecoder;
}();

;

exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhobW0tZGVjb2Rlci5qcyJdLCJuYW1lcyI6WyJoaG1tVXRpbHMiLCJIaG1tRGVjb2RlciIsIndpbmRvd1NpemUiLCJfbGlrZWxpaG9vZFdpbmRvdyIsIl9tb2RlbCIsInVuZGVmaW5lZCIsIl9tb2RlbFJlc3VsdHMiLCJvYnNlcnZhdGlvbiIsInJlc3VsdHNDYWxsYmFjayIsImVyciIsInJlcyIsImNvbnNvbGUiLCJsb2ciLCJoaG1tRmlsdGVyIiwibGlrZWxpZXN0IiwibW9kZWxzIiwibGFiZWwiLCJsaWtlbGlob29kcyIsInNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMiLCJzbGljZSIsImxpa2VsaWVzdEluZGV4IiwidGltZVByb2dyZXNzaW9ucyIsIkFycmF5IiwibGVuZ3RoIiwiYWxwaGFzIiwiaSIsInNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzIiwicHJvZ3Jlc3MiLCJjb25maWd1cmF0aW9uIiwiZGVmYXVsdF9wYXJhbWV0ZXJzIiwiaGllcmFyY2hpY2FsIiwiYWxwaGFfaCIsImFscGhhIiwic2hhcmVkX3BhcmFtZXRlcnMiLCJiaW1vZGFsIiwib3V0cHV0X3ZhbHVlcyIsIm91dHB1dF9jb3ZhcmlhbmNlIiwiZSIsIl9zZXRNb2RlbCIsIm5ld1dpbmRvd1NpemUiLCJfdXBkYXRlTGlrZWxpaG9vZFdpbmRvdyIsImxpa2VsaWhvb2RfYnVmZmVyIiwiaiIsIkpTT04iLCJwYXJzZSIsIm1vZGVsIiwibSIsIm5tb2RlbHMiLCJpbnN0YW50X2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbGlrZWxpaG9vZHMiLCJpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMiLCJmcm9udGllcl92MSIsImZyb250aWVyX3YyIiwiZm9yd2FyZF9pbml0aWFsaXplZCIsInBhcmFtcyIsImRpbU91dCIsImRpbWVuc2lvbiIsImRpbWVuc2lvbl9pbnB1dCIsIm91dENvdmFyU2l6ZSIsImNvdmFyaWFuY2VfbW9kZSIsIm5zdGF0ZXMiLCJwYXJhbWV0ZXJzIiwic3RhdGVzIiwiayIsImhtbVJlcyIsImluc3RhbnRfbGlrZWxpaG9vZCIsImxvZ19saWtlbGlob29kIiwibGlrZWxpaG9vZF9idWZmZXJfaW5kZXgiLCJleGl0X2xpa2VsaWhvb2QiLCJleGl0X3JhdGlvIiwibGlrZWxpZXN0X3N0YXRlIiwicHJldmlvdXNfYWxwaGEiLCJ3aW5kb3dfbWluaW5kZXgiLCJ3aW5kb3dfbWF4aW5kZXgiLCJ3aW5kb3dfbm9ybWFsaXphdGlvbl9jb25zdGFudCIsInNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzIiwiZ21tUmVzIiwiYmV0YSIsImdhdXNzaWFucyIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQUFZQSxTOzs7Ozs7QUFFWjs7Ozs7OztJQU9NQyxXOztBQUVKOzs7QUFHQSx5QkFBNEI7QUFBQSxRQUFoQkMsVUFBZ0IsdUVBQUgsQ0FBRztBQUFBOzs7QUFFMUI7Ozs7O0FBS0EsU0FBS0MsaUJBQUwsR0FBeUJELFVBQXpCOztBQUVBOzs7OztBQUtBLFNBQUtFLE1BQUwsR0FBY0MsU0FBZDs7QUFFQTs7Ozs7QUFLQSxTQUFLQyxhQUFMLEdBQXFCRCxTQUFyQjtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7MkJBTU9FLFcsRUFBcUM7QUFBQSxVQUF4QkMsZUFBd0IsdUVBQU4sSUFBTTs7QUFDMUMsVUFBSUMsTUFBTSxJQUFWO0FBQ0EsVUFBSUMsTUFBTSxJQUFWOztBQUVBLFVBQUcsQ0FBQyxLQUFLTixNQUFULEVBQWlCO0FBQ2ZLLGNBQU0scUJBQU47QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJO0FBQ0ZFLGtCQUFRQyxHQUFSLENBQVksVUFBWjtBQUNBWixvQkFBVWEsVUFBVixDQUFxQk4sV0FBckIsRUFBa0MsS0FBS0gsTUFBdkMsRUFBK0MsS0FBS0UsYUFBcEQ7O0FBRUE7QUFDQSxjQUFNUSxZQUFhLEtBQUtSLGFBQUwsQ0FBbUJRLFNB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S0FBS25ELE1BQUwsQ0FBWTZCLGlCQUEzQjtBQUNBLGVBQU9zQixPQUFPLFNBQVAsSUFDQUEsT0FBTyxXQUFQLElBQXNCQSxPQUFPLGlCQUFQLENBRHRCLEdBRUEsQ0FGUDtBQUdEO0FBQ0QsYUFBTyxDQUFQO0FBQ0Q7Ozs7O0FBQ0Y7O2tCQUVjdEQsVyIsImZpbGUiOiJoaG1tLWRlY29kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBoaG1tVXRpbHMgZnJvbSAnLi4vdXRpbHMvaGhtbS11dGlscyc7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIEhNTSBkZWNvZGVyIDxiciAvPlxuICogTG9hZHMgYSBtb2RlbCB0cmFpbmVkIGJ5IHRoZSBYTU0gbGlicmFyeSBhbmQgcHJvY2Vzc2VzIGFuIGlucHV0IHN0cmVhbSBvZiBmbG9hdCB2ZWN0b3JzIGluIHJlYWwtdGltZS5cbiAqIElmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCBmb3IgcmVncmVzc2lvbiwgb3V0cHV0cyBhbiBlc3RpbWF0aW9uIG9mIHRoZSBhc3NvY2lhdGVkIHByb2Nlc3MuXG4gKiBAY2xhc3NcbiAqL1xuXG5jbGFzcyBIaG1tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZT0xXSAtIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSB3aW5kb3dTaXplO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgcmVzdWx0cywgY29udGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBpbiBmaWx0ZXIuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEBjYWxsYmFjayBoaG1tUmVzdWx0c0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBEZXNjcmlwdGlvbiBvZiBhIHBvdGVudGlhbCBlcnJvci5cbiAgICogQHBhcmFtIHtoaG1tUmVzdWx0c30gcmVzIC0gT2JqZWN0IGhvbGRpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc3VsdHMgb2YgdGhlIGZpbHRlcmluZyBwcm9jZXNzLlxuICAgKiBAdHlwZWRlZiBoaG1tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAbmFtZSBoaG1tUmVzdWx0c1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbGlrZWxpZXN0IC0gVGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbGlrZWxpZXN0SW5kZXggLSBUaGUgbGlrZWxpZXN0IG1vZGVsJ3MgaW5kZXhcbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IGxpa2VsaWhvb2RzIC0gVGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIHNtb290aGVkIG5vcm1hbGl6ZWQgbGlrZWxpaG9vZHMuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSB0aW1lUHJvZ3Jlc3Npb25zIC0gVGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIG5vcm1hbGl6ZWQgdGltZSBwcm9ncmVzc2lvbnMuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuQXJyYXkubnVtYmVyfSBhbHBoYXMgLSBUaGUgYXJyYXkgb2YgYWxsIG1vZGVscycgc3RhdGVzIGxpa2VsaWhvb2RzIGFycmF5LlxuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dFZhbHVlcyAtIElmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoIHJlZ3Jlc3Npb24sIHRoZSBlc3RpbWF0ZWQgZmxvYXQgdmVjdG9yIG91dHB1dC5cbiAgICogQHByb3BlcnR5IHs/QXJyYXkubnVtYmVyfSBvdXRwdXRDb3ZhcmlhbmNlIC0gSWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIG91dHB1dCBjb3ZhcmlhbmNlIG1hdHJpeC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBkZWNvZGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheS5udW1iZXJ9IG9ic2VydmF0aW9uIC0gQW4gaW5wdXQgZmxvYXQgdmVjdG9yIHRvIGJlIGVzdGltYXRlZC5cbiAgICogQHBhcmFtIHtoaG1tUmVzdWx0c0NhbGxiYWNrfSBbcmVzdWx0c0NhbGxiYWNrPW51bGxdIC0gVGhlIGNhbGxiYWNrIGhhbmRsaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEByZXR1cm5zIHtoaG1tUmVzdWx0c31cbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrID0gbnVsbCkge1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCByZXMgPSBudWxsO1xuXG4gICAgaWYoIXRoaXMuX21vZGVsKSB7XG4gICAgICBlcnIgPSAnbm8gbW9kZWwgbG9hZGVkIHlldCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmaWx0ZXIgIScpO1xuICAgICAgICBoaG1tVXRpbHMuaGhtbUZpbHRlcihvYnNlcnZhdGlvbiwgdGhpcy5fbW9kZWwsIHRoaXMuX21vZGVsUmVzdWx0cyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlc3VsdHMgb2JqZWN0IGZyb20gcmVsZXZhbnQgbW9kZWxSZXN1bHRzIHZhbHVlcyA6XG4gICAgICAgIGNvbnN0IGxpa2VsaWVzdCA9ICh0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX21vZGVsLm1vZGVsc1t0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0XS5sYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnN0IGxpa2VsaWhvb2RzID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMuc2xpY2UoMCk7XG4gICAgICAgIHJlcyA9IHtcbiAgICAgICAgICBsaWtlbGllc3Q6IGxpa2VsaWVzdCxcbiAgICAgICAgICBsaWtlbGllc3RJbmRleDogdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCxcbiAgICAgICAgICBsaWtlbGlob29kczogbGlrZWxpaG9vZHMsXG4gICAgICAgICAgdGltZVByb2dyZXNzaW9uczogbmV3IEFycmF5KHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGgpLFxuICAgICAgICAgIGFscGhhczogbmV3IEFycmF5KHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXMudGltZVByb2dyZXNzaW9uc1tpXSA9IHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0c1tpXS5wcm9ncmVzcztcbiAgICAgICAgICBpZiAodGhpcy5fbW9kZWwuY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuaGllcmFyY2hpY2FsKSB7XG4gICAgICAgICAgICByZXMuYWxwaGFzW2ldXG4gICAgICAgICAgICAgID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzW2ldLmFscGhhX2hbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5hbHBoYXNbaV1cbiAgICAgICAgICAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0uYWxwaGFbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21vZGVsLnNoYXJlZF9wYXJhbWV0ZXJzLmJpbW9kYWwpIHtcbiAgICAgICAgICByZXNbJ291dHB1dFZhbHVlcyddID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgcmVzWydvdXRwdXRDb3ZhcmlhbmNlJ11cbiAgICAgICAgICAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gJ3Byb2JsZW0gb2NjdXJlZCBkdXJpbmcgZmlsdGVyaW5nIDogJyArIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdHNDYWxsYmFjaykge1xuICAgICAgcmVzdWx0c0NhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybWVkaWF0ZSByZXN1bHRzIG9mIHRoZSBlc3RpbWF0aW9uIChzaG9ydGN1dCBmb3IgcmVsb2FkaW5nIHRoZSBtb2RlbCkuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIHRoaXMuX3NldE1vZGVsKHRoaXMuX21vZGVsKTtcbiAgICB9XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgLyBTRVRURVJTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cblxuICAvKioqXG4gICAqIExpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdyBzaXplLlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgLy8gZ2V0IGxpa2VsaWhvb2RXaW5kb3coKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gIC8vIH1cblxuICAvLyBzZXQgbGlrZWxpaG9vZFdpbmRvdyhuZXdXaW5kb3dTaXplKSB7XG4gIC8vICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IG5ld1dpbmRvd1NpemU7XG4gIC8vICAgdGhpcy5fdXBkYXRlTGlrZWxpaG9vZFdpbmRvdygpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93IHNpemUuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRMaWtlbGlob29kV2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93IHNpemUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdXaW5kb3dTaXplIC0gdGhlIG5ldyB3aW5kb3cgc2l6ZS5cbiAgICovXG4gIHNldExpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUxpa2VsaWhvb2RXaW5kb3coKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfdXBkYXRlTGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdzsgaisrKSB7XG4gICAgICAgIHJlc1tpXS5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAgICAgfVxuICAgIH0gICAgXG4gIH1cblxuICAvKipcbiAgICogQSB2YWxpZCBYTU0gSGllcmFyY2hpY2FsIEhNTSBtb2RlbFxuICAgKiBAdHlwZWRlZiB4bW1IaG1tTW9kZWxcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQG5hbWUgeG1tSGhtbU1vZGVsXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBUT0RPIC0gTElTVCBSRUFMIEhITU0gTU9ERUwgUFJPUEVSVElFUyBIRVJFXG4gICAqL1xuXG4gIC8qKipcbiAgICogVGhlIG1vZGVsIGdlbmVyYXRlZCBieSBYTU0uXG4gICAqIEl0IGlzIG1hbmRhdG9yeSBmb3IgdGhlIGNsYXNzIHRvIGhhdmUgYSBtb2RlbCBpbiBvcmRlciB0byBkbyBpdHMgam9iLlxuICAgKiBAdHlwZSB7eG1tSGhtbU1vZGVsfVxuICAgKi9cbiAgLy8gZ2V0IG1vZGVsKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmdldE1vZGVsKCk7XG4gIC8vIH1cblxuICAvLyBzZXQgbW9kZWwobW9kZWwpIHtcbiAgLy8gICB0aGlzLnNldE1vZGVsKG1vZGVsKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFjdHVhbCBYTU0gSGllcmFyY2hpY2FsIEhNTSBtb2RlbC5cbiAgICogQHJldHVybnMge3htbUhobW1Nb2RlbH1cbiAgICovXG4gIGdldE1vZGVsKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fbW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDsgICAgXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhY3R1YWwgWE1NIEhpZXJhcmNoaWNhbCBITU0gbW9kZWwuXG4gICAqIEBwYXJhbSB7eG1tSGhtbU1vZGVsfSBtb2RlbFxuICAgKi9cbiAgc2V0TW9kZWwobW9kZWwpIHtcbiAgICB0aGlzLl9zZXRNb2RlbChtb2RlbCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3NldE1vZGVsKG1vZGVsKSB7ICAgICAgXG5cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tb2RlbFJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIW1vZGVsKSByZXR1cm47XG5cbiAgICAvLyB0ZXN0IGlmIG1vZGVsIGlzIHZhbGlkIGhlcmUgKFRPRE8gOiB3cml0ZSBhIGJldHRlciB0ZXN0KVxuICAgIGlmIChtb2RlbC5tb2RlbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLl9tb2RlbDtcbiAgICAgIGNvbnN0IG5tb2RlbHMgPSBtLm1vZGVscy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHtcbiAgICAgICAgaW5zdGFudF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9sb2dfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgaW5zdGFudF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgbGlrZWxpZXN0OiAtMSxcbiAgICAgICAgZnJvbnRpZXJfdjE6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgZnJvbnRpZXJfdjI6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgZm9yd2FyZF9pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgIHNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzOiBbXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGRpbU91dCA9IHBhcmFtcy5kaW1lbnNpb24gLSBwYXJhbXMuZGltZW5zaW9uX2lucHV0O1xuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMgPSBuZXcgQXJyYXkoZGltT3V0KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXNbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRDb3ZhclNpemU7XG4gICAgICBpZiAobS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5jb3ZhcmlhbmNlX21vZGUgPT0gMCkgeyAvLy0tLS0gZnVsbFxuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQgKiBkaW1PdXQ7XG4gICAgICB9IGVsc2UgeyAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkaWFnb25hbFxuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZSA9IG5ldyBBcnJheShvdXRDb3ZhclNpemUpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZVtpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBubW9kZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzW2ldID0gMDtcblxuICAgICAgICBjb25zdCBuc3RhdGVzID0gbS5tb2RlbHNbaV0ucGFyYW1ldGVycy5zdGF0ZXM7XG5cbiAgICAgICAgY29uc3QgYWxwaGFfaCA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICBhbHBoYV9oW2pdID0gbmV3IEFycmF5KG5zdGF0ZXMpO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnN0YXRlczsgaysrKSB7XG4gICAgICAgICAgICBhbHBoYV9oW2pdW2tdID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFscGhhID0gbmV3IEFycmF5KG5zdGF0ZXMpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5zdGF0ZXM7IGorKykge1xuICAgICAgICAgIGFscGhhW2pdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsaWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcltqXSA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhtbVJlcyA9IHtcbiAgICAgICAgICBoaWVyYXJjaGljYWw6IG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuaGllcmFyY2hpY2FsLFxuICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICAvLyBmb3IgY2lyY3VsYXIgYnVmZmVyIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgLy8gKHNlZSBobW1VcGRhdGVSZXN1bHRzKSA6XG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXI6IGxpa2VsaWhvb2RfYnVmZmVyLFxuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyX2luZGV4OiAwLFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuXG4gICAgICAgICAgZXhpdF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGV4aXRfcmF0aW86IDAsXG5cbiAgICAgICAgICBsaWtlbGllc3Rfc3RhdGU6IC0xLFxuXG4gICAgICAgICAgLy8gZm9yIG5vbi1oaWVyYXJjaGljYWwgOlxuICAgICAgICAgIHByZXZpb3VzX2FscGhhOiBhbHBoYS5zbGljZSgwKSxcbiAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgICAgLy8gZm9yIGhpZXJhcmNoaWNhbCA6ICAgICAgIFxuICAgICAgICAgIGFscGhhX2g6IGFscGhhX2gsXG4gICAgICAgICAgLy8gcHJpb3I6IG5ldyBBcnJheShuc3RhdGVzKSxcbiAgICAgICAgICAvLyB0cmFuc2l0aW9uOiBuZXcgQXJyYXkobnN0YXRlcyksXG5cbiAgICAgICAgICAvLyB1c2VkIGluIGhtbVVwZGF0ZUFscGhhV2luZG93XG4gICAgICAgICAgd2luZG93X21pbmluZGV4OiAwLFxuICAgICAgICAgIHdpbmRvd19tYXhpbmRleDogMCxcbiAgICAgICAgICB3aW5kb3dfbm9ybWFsaXphdGlvbl9jb25zdGFudDogMCxcblxuICAgICAgICAgIC8vIGZvciBub24taGllcmFyY2hpY2FsIG1vZGVcbiAgICAgICAgICBmb3J3YXJkX2luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICBcbiAgICAgICAgICBzaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0czogW10gIC8vIGFrYSBzdGF0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBobW1SZXMub3V0cHV0X3ZhbHVlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICBobW1SZXMub3V0cHV0X2NvdmFyaWFuY2UgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gYWRkIEhNTSBzdGF0ZXMgKEdNTXMpXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnN0YXRlczsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZ21tUmVzID0ge1xuICAgICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgICAgbG9nX2xpa2VsaWhvb2Q6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdtbVJlcy5iZXRhID0gbmV3IEFycmF5KHRoaXMuX21vZGVsLm1vZGVsc1tpXS5wYXJhbWV0ZXJzLmdhdXNzaWFucyk7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBnbW1SZXMuYmV0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ21tUmVzLmJldGFba10gPSAxIC8gZ21tUmVzLmJldGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnbW1SZXMub3V0cHV0X3ZhbHVlcyA9IGhtbVJlcy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIGdtbVJlcy5vdXRwdXRfY292YXJpYW5jZSA9IGhtbVJlcy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAgIGhtbVJlcy5zaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0cy5wdXNoKGdtbVJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHMucHVzaChobW1SZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKipcbiAgICogQ3VycmVudGx5IGVzdGltYXRlZCBsaWtlbGllc3QgbGFiZWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgLy8gZ2V0IGxpa2VsaWVzdExhYmVsKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmdldExpa2VsaWVzdExhYmVsKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50bHkgZXN0aW1hdGVkIGxpa2VsaWVzdCBsYWJlbC5cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldExpa2VsaWVzdExhYmVsKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbFJlc3VsdHMpIHtcbiAgICAgIGlmICh0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVsc1t0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0XS5sYWJlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICd1bmtub3duJzsgICAgXG4gIH1cblxuICAvKioqXG4gICAqIE51bWJlciBvZiBjbGFzc2VzIGNvbnRhaW5lZCBpbiB0aGUgbW9kZWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgLy8gZ2V0IG5iQ2xhc3NlcygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXROdW1iZXJPZkNsYXNzZXMoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBjbGFzc2VzIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0TnVtYmVyT2ZDbGFzc2VzKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqKlxuICAgKiBTaXplIG9mIHRoZSByZWdyZXNzaW9uIHZlY3RvciBpZiBtb2RlbCBpcyBiaW1vZGFsLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIC8vIGdldCByZWdyZXNzaW9uU2l6ZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRSZWdyZXNzaW9uVmVjdG9yU2l6ZSgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGRpbWVuc2lvbiBvZiB0aGUgbW9kZWwgKHNpemUgb2YgYSByZWdyZXNzaW9uIHZlY3RvcikuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWdyZXNzaW9uVmVjdG9yU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX21vZGVsLnNoYXJlZF9wYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHBhcmFtc1snYmltb2RhbCddXG4gICAgICAgICAgID8gcGFyYW1zWydkaW1lbnNpb24nXSAtIHBhcmFtc1snZGltZW5zaW9uX2lucHV0J11cbiAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSGhtbURlY29kZXI7Il19