'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vectors in real-time
 * if the model was trained for regression, outputs an estimation
 * @class
 */

var HhmmDecoder = function () {

  /**
   * @param {number} windowSize - size of the likelihood smoothing window
   */
  function HhmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * Size of the likelihood smoothing window
     * @type {number}
     */
    this._likelihoodWindow = windowSize;

    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter
     * @type {Object}
     */
    this._modelResults = undefined;
  }

  /**
   * @typedef HhmmResults
   * @type {Object}
   * @property {string} likeliest - the likeliest model's label
   * @property {Array.number} likelihoods - the array of all models' normalized likelihoods
   * @property {Array.number} timeProgressions - the array of all models' normalized time progressions
   * @property {Array.Array.number} alphas - the array of all models' states likelihoods array
   * @property {?Array.number} outputValues - if the model was trained with regression, the estimated float vector output
   */

  /**
   * Callback handling estimation results
   * @callback ResultsCallback
   * @param {string} err - description of a potential error
   * @param {HhmmResults} res - object holding the estimation results
   */

  /**
   * The decoding function
   * @param {Array.number} observation - an input float vector to be estimated
   * @param {ResultsCallback} resultsCallback - the callback handling the estimation results
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      var err = null;
      var res = null;

      if (this._model === undefined) {
        err = 'no model loaded yet';
      } else {
        //console.log(observation);
        //this._observation = observation;
        try {
          hhmmUtils.hhmmFilter(observation, this._model, this._modelResults);

          // create results object from relevant modelResults values :

          var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: likeliest,
            likeliestIndex: this._modelResults.likeliest,
            likelihoods: likelihoods,
            alphas: new Array(this._model.models.length)
          };

          for (var i = 0; i < this._model.models.length; i++) {
            if (this._model.configuration.default_parameters.hierarchical) {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha_h[0];
            } else {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha[0];
            }
          }

          if (this._model.shared_parameters.bimodal) {
            res.outputValues = this._modelResults.output_values.slice(0);
            // results.outputCovariance
            //     = this._modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      resultsCallback(err, res);
    }

    /**
     * Resets the intermediate results of the estimation
     */

  }, {
    key: 'reset',
    value: function reset() {
      /** @todo : write a real reset (see c++ version) */
      this._modelResults.forward_initialized = false;
    }

    // ==================== SETTERS ====================== //

    /**
     * The model generated by XMM
     * It is mandatory for the class to have a model in order to do its job
     * @type {Object}
     */

  }, {
    key: 'model',
    set: function set(model) {

      this._model = undefined;
      this._modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {

        //console.log(model);

        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;

        // not used anymore (returns a more complex js object)
        // const nstatesGlobal = m.configuration.default_parameters.states;
        // this.params.frameSize = nstatesGlobal;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        // move output_values / output_covariance here for regression
        // and dupe (.slice(0)) them in sub-modelResults
        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          // full
          outCovarSize = dimOut * dimOut;
        } else {
          // diagonal
          outCovarSize = dimOut;
        }
        this._modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var nstates = m.models[_i2].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          // const winSize = m.shared_parameters.likelihood_window
          // let likelihood_buffer = new Array(winSize);
          var likelihood_buffer = new Array(this._likelihoodWindow);
          for (var _j2 = 0; _j2 < this._likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            prior: new Array(nstates),
            transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // states
          };

          hmmRes.output_values = this._modelResults.output_values.slice(0);
          hmmRes.output_covariance = this._modelResults.output_covariance.slice(0);

          // add HMM states (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this._model.models[_i2].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this._modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }
    },
    get: function get() {
      if (this._model !== undefined) {
        return JSON.fromString((0, _stringify2.default)(this._model));
      }
      return undefined;
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      if (this._model === undefined) return;
      var res = this._modelResults.singleClassModelResults;
      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);
        for (var j = 0; j < this._likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    // ==================== GETTERS ====================== //

    ,
    get: function get() {
      return this._likelihoodWindow;
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this._modelResults !== undefined) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
      //return('no estimation available');
    }
  }, {
    key: 'nbClasses',
    get: function get() {
      if (this._model !== undefined) {
        return this._model.models.length;
      }
      return 0;
    }
  }]);
  return HhmmDecoder;
}(); //import * as gmmUtils from '../utils/gmm-utils';


exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,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Q0FBc0IsQ0FBdEIsSUFBMkIsSUFBSSxLQUFLLGlCQUFwQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O3dCQTBCdUI7QUFDckIsYUFBTyxLQUFLLGlCQUFaO0FBQ0Q7Ozt3QkExQm9CO0FBQ25CLFVBQUcsS0FBSyxhQUFMLEtBQXVCLFNBQTFCLEVBQXFDO0FBQ25DLFlBQUcsS0FBSyxhQUFMLENBQW1CLFNBQW5CLEdBQStCLENBQUMsQ0FBbkMsRUFBc0M7QUFDcEMsaUJBQU8sS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLGFBQUwsQ0FBbUIsU0FBdEMsRUFBaUQsS0FBeEQ7QUFDRDtBQUNGO0FBQ0QsYUFBTyxTQUFQO0FBQ0E7QUFDRDs7O3dCQUVlO0FBQ2QsVUFBRyxLQUFLLE1BQUwsS0FBZ0IsU0FBbkIsRUFBOEI7QUFDNUIsZUFBTyxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLE1BQTFCO0FBQ0Q7QUFDRCxhQUFPLENBQVA7QUFDRDs7O0tBbFNIOzs7a0JBVXFCLFciLCJmaWxlIjoiaGhtbS1kZWNvZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgKiBhcyBnbW1VdGlscyBmcm9tICcuLi91dGlscy9nbW0tdXRpbHMnO1xuaW1wb3J0ICogYXMgaGhtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2hobW0tdXRpbHMnO1xuXG4vKipcbiAqIEhpZXJhcmNoaWNhbCBITU0gZGVjb2RlclxuICogbG9hZHMgYSBtb2RlbCB0cmFpbmVkIGJ5IHRoZSBYTU0gbGlicmFyeSBhbmQgcHJvY2Vzc2VzIGFuIGlucHV0IHN0cmVhbSBvZiBmbG9hdCB2ZWN0b3JzIGluIHJlYWwtdGltZVxuICogaWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIGZvciByZWdyZXNzaW9uLCBvdXRwdXRzIGFuIGVzdGltYXRpb25cbiAqIEBjbGFzc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhobW1EZWNvZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemUgLSBzaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3dcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3dcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSB3aW5kb3dTaXplO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgcmVzdWx0cywgY29udGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBpbiBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiBIaG1tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGlrZWxpZXN0IC0gdGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSBsaWtlbGlob29kcyAtIHRoZSBhcnJheSBvZiBhbGwgbW9kZWxzJyBub3JtYWxpemVkIGxpa2VsaWhvb2RzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSB0aW1lUHJvZ3Jlc3Npb25zIC0gdGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIG5vcm1hbGl6ZWQgdGltZSBwcm9ncmVzc2lvbnNcbiAgICogQHByb3BlcnR5IHtBcnJheS5BcnJheS5udW1iZXJ9IGFscGhhcyAtIHRoZSBhcnJheSBvZiBhbGwgbW9kZWxzJyBzdGF0ZXMgbGlrZWxpaG9vZHMgYXJyYXlcbiAgICogQHByb3BlcnR5IHs/QXJyYXkubnVtYmVyfSBvdXRwdXRWYWx1ZXMgLSBpZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgd2l0aCByZWdyZXNzaW9uLCB0aGUgZXN0aW1hdGVkIGZsb2F0IHZlY3RvciBvdXRwdXRcbiAgICovXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGhhbmRsaW5nIGVzdGltYXRpb24gcmVzdWx0c1xuICAgKiBAY2FsbGJhY2sgUmVzdWx0c0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBkZXNjcmlwdGlvbiBvZiBhIHBvdGVudGlhbCBlcnJvclxuICAgKiBAcGFyYW0ge0hobW1SZXN1bHRzfSByZXMgLSBvYmplY3QgaG9sZGluZyB0aGUgZXN0aW1hdGlvbiByZXN1bHRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZGVjb2RpbmcgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheS5udW1iZXJ9IG9ic2VydmF0aW9uIC0gYW4gaW5wdXQgZmxvYXQgdmVjdG9yIHRvIGJlIGVzdGltYXRlZFxuICAgKiBAcGFyYW0ge1Jlc3VsdHNDYWxsYmFja30gcmVzdWx0c0NhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIGhhbmRsaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHNcbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrKSB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICBpZih0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnIgPSAnbm8gbW9kZWwgbG9hZGVkIHlldCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29uc29sZS5sb2cob2JzZXJ2YXRpb24pO1xuICAgICAgLy90aGlzLl9vYnNlcnZhdGlvbiA9IG9ic2VydmF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGhtbVV0aWxzLmhobW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMuX21vZGVsLCB0aGlzLl9tb2RlbFJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXN1bHRzIG9iamVjdCBmcm9tIHJlbGV2YW50IG1vZGVsUmVzdWx0cyB2YWx1ZXMgOlxuXG4gICAgICAgIGNvbnN0IGxpa2VsaWVzdCA9ICh0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuX21vZGVsLm1vZGVsc1t0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0XS5sYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnN0IGxpa2VsaWhvb2RzID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMuc2xpY2UoMCk7XG4gICAgICAgIHJlcyA9IHtcbiAgICAgICAgICBsaWtlbGllc3Q6IGxpa2VsaWVzdCxcbiAgICAgICAgICBsaWtlbGllc3RJbmRleDogdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCxcbiAgICAgICAgICBsaWtlbGlob29kczogbGlrZWxpaG9vZHMsXG4gICAgICAgICAgYWxwaGFzOiBuZXcgQXJyYXkodGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZih0aGlzLl9tb2RlbC5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5oaWVyYXJjaGljYWwpIHtcbiAgICAgICAgICAgIHJlcy5hbHBoYXNbaV1cbiAgICAgICAgICAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0uYWxwaGFfaFswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLmFscGhhc1tpXVxuICAgICAgICAgICAgICA9IHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0c1tpXS5hbHBoYVswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgICAgcmVzLm91dHB1dFZhbHVlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIC8vIHJlc3VsdHMub3V0cHV0Q292YXJpYW5jZVxuICAgICAgICAgIC8vICAgICA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSAncHJvYmxlbSBvY2N1cmVkIGR1cmluZyBmaWx0ZXJpbmcgOiAnICsgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRzQ2FsbGJhY2soZXJyLCByZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgb2YgdGhlIGVzdGltYXRpb25cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIC8qKiBAdG9kbyA6IHdyaXRlIGEgcmVhbCByZXNldCAoc2VlIGMrKyB2ZXJzaW9uKSAqL1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cy5mb3J3YXJkX2luaXRpYWxpemVkID0gZmFsc2U7XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBTRVRURVJTID09PT09PT09PT09PT09PT09PT09PT0gLy9cblxuICAvKipcbiAgICogVGhlIG1vZGVsIGdlbmVyYXRlZCBieSBYTU1cbiAgICogSXQgaXMgbWFuZGF0b3J5IGZvciB0aGUgY2xhc3MgdG8gaGF2ZSBhIG1vZGVsIGluIG9yZGVyIHRvIGRvIGl0cyBqb2JcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHNldCBtb2RlbChtb2RlbCkgeyAgICAgIFxuXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gdGVzdCBpZiBtb2RlbCBpcyB2YWxpZCBoZXJlIChUT0RPIDogd3JpdGUgYSBiZXR0ZXIgdGVzdClcbiAgICBpZihtb2RlbC5tb2RlbHMgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvL2NvbnNvbGUubG9nKG1vZGVsKTtcblxuICAgICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLl9tb2RlbDtcbiAgICAgIGNvbnN0IG5tb2RlbHMgPSBtLm1vZGVscy5sZW5ndGg7XG5cbiAgICAgIC8vIG5vdCB1c2VkIGFueW1vcmUgKHJldHVybnMgYSBtb3JlIGNvbXBsZXgganMgb2JqZWN0KVxuICAgICAgLy8gY29uc3QgbnN0YXRlc0dsb2JhbCA9IG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuc3RhdGVzO1xuICAgICAgLy8gdGhpcy5wYXJhbXMuZnJhbWVTaXplID0gbnN0YXRlc0dsb2JhbDtcblxuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzID0ge1xuICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xvZ19saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBsaWtlbGllc3Q6IC0xLFxuICAgICAgICBmcm9udGllcl92MTogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBmcm9udGllcl92MjogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBmb3J3YXJkX2luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHM6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBtb3ZlIG91dHB1dF92YWx1ZXMgLyBvdXRwdXRfY292YXJpYW5jZSBoZXJlIGZvciByZWdyZXNzaW9uXG4gICAgICAvLyBhbmQgZHVwZSAoLnNsaWNlKDApKSB0aGVtIGluIHN1Yi1tb2RlbFJlc3VsdHNcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG0uc2hhcmVkX3BhcmFtZXRlcnM7XG4gICAgICBjb25zdCBkaW1PdXQgPSBwYXJhbXMuZGltZW5zaW9uIC0gcGFyYW1zLmRpbWVuc2lvbl9pbnB1dDtcbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzID0gbmV3IEFycmF5KGRpbU91dCk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXNbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRDb3ZhclNpemU7XG4gICAgICBpZihtLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmNvdmFyaWFuY2VfbW9kZSA9PSAwKSB7IC8vIGZ1bGxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0ICogZGltT3V0O1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIGRpYWdvbmFsXG4gICAgICAgIG91dENvdmFyU2l6ZSA9IGRpbU91dDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZSA9IG5ldyBBcnJheShvdXRDb3ZhclNpemUpO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZVtpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5tb2RlbHM7IGkrKykge1xuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgbnN0YXRlcyA9IG0ubW9kZWxzW2ldLnBhcmFtZXRlcnMuc3RhdGVzO1xuXG4gICAgICAgIGNvbnN0IGFscGhhX2ggPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgIGZvcihsZXQgaj0wOyBqPDM7IGorKykge1xuICAgICAgICAgIGFscGhhX2hbal0gPSBuZXcgQXJyYXkobnN0YXRlcyk7XG4gICAgICAgICAgZm9yKGxldCBrPTA7IGs8bnN0YXRlczsgaysrKSB7XG4gICAgICAgICAgICBhbHBoYV9oW2pdW2tdID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGFscGhhID0gbmV3IEFycmF5KG5zdGF0ZXMpO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbnN0YXRlczsgaisrKSB7XG4gICAgICAgICAgYWxwaGFbal0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3Qgd2luU2l6ZSA9IG0uc2hhcmVkX3BhcmFtZXRlcnMubGlrZWxpaG9vZF93aW5kb3dcbiAgICAgICAgLy8gbGV0IGxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHdpblNpemUpO1xuICAgICAgICBsZXQgbGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcltqXSA9IDAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhtbVJlcyA9IHtcbiAgICAgICAgICBoaWVyYXJjaGljYWw6IG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuaGllcmFyY2hpY2FsLFxuICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICAvLyBmb3IgY2lyY3VsYXIgYnVmZmVyIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgLy8gKHNlZSBobW1VcGRhdGVSZXN1bHRzKSA6XG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXI6IGxpa2VsaWhvb2RfYnVmZmVyLFxuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyX2luZGV4OiAwLFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuXG4gICAgICAgICAgZXhpdF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGV4aXRfcmF0aW86IDAsXG5cbiAgICAgICAgICBsaWtlbGllc3Rfc3RhdGU6IC0xLFxuXG4gICAgICAgICAgLy8gZm9yIG5vbi1oaWVyYXJjaGljYWwgOlxuICAgICAgICAgIHByZXZpb3VzX2FscGhhOiBhbHBoYS5zbGljZSgwKSxcbiAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgICAgLy8gZm9yIGhpZXJhcmNoaWNhbCA6ICAgICAgIFxuICAgICAgICAgIGFscGhhX2g6IGFscGhhX2gsXG4gICAgICAgICAgcHJpb3I6IG5ldyBBcnJheShuc3RhdGVzKSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBuZXcgQXJyYXkobnN0YXRlcyksXG5cbiAgICAgICAgICAvLyB1c2VkIGluIGhtbVVwZGF0ZUFscGhhV2luZG93XG4gICAgICAgICAgd2luZG93X21pbmluZGV4OiAwLFxuICAgICAgICAgIHdpbmRvd19tYXhpbmRleDogMCxcbiAgICAgICAgICB3aW5kb3dfbm9ybWFsaXphdGlvbl9jb25zdGFudDogMCxcblxuICAgICAgICAgIC8vIGZvciBub24taGllcmFyY2hpY2FsIG1vZGVcbiAgICAgICAgICBmb3J3YXJkX2luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICBcbiAgICAgICAgICBzaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0czogW10gIC8vIHN0YXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGhtbVJlcy5vdXRwdXRfdmFsdWVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIGhtbVJlcy5vdXRwdXRfY292YXJpYW5jZSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBhZGQgSE1NIHN0YXRlcyAoR01NcylcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG5zdGF0ZXM7IGorKykge1xuICAgICAgICAgIGNvbnN0IGdtbVJlcyA9IHtcbiAgICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbW1SZXMuYmV0YSA9IG5ldyBBcnJheSh0aGlzLl9tb2RlbC5tb2RlbHNbaV0ucGFyYW1ldGVycy5nYXVzc2lhbnMpO1xuICAgICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCBnbW1SZXMuYmV0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZ21tUmVzLmJldGFba10gPSAxIC8gZ21tUmVzLmJldGEubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnbW1SZXMub3V0cHV0X3ZhbHVlcyA9IGhtbVJlcy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIGdtbVJlcy5vdXRwdXRfY292YXJpYW5jZSA9IGhtbVJlcy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAgIGhtbVJlcy5zaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0cy5wdXNoKGdtbVJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHMucHVzaChobW1SZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldCBsaWtlbGlob29kV2luZG93KG5ld1dpbmRvd1NpemUpIHtcbiAgICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gbmV3V2luZG93U2l6ZTtcbiAgICBpZih0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgY29uc3QgcmVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzTW9kZWxSZXN1bHRzO1xuICAgIGZvcihsZXQgaT0wOyBpPHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cpO1xuICAgICAgZm9yKGxldCBqPTA7IGo8dGhpcy5fbGlrZWxpaG9vZFdpbmRvdzsgaisrKSB7XG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09PSAvL1xuXG4gIGdldCBsaWtlbGllc3RMYWJlbCgpIHtcbiAgICBpZih0aGlzLl9tb2RlbFJlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG4gICAgLy9yZXR1cm4oJ25vIGVzdGltYXRpb24gYXZhaWxhYmxlJyk7XG4gIH1cblxuICBnZXQgbmJDbGFzc2VzKCkge1xuICAgIGlmKHRoaXMuX21vZGVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldCBtb2RlbCgpIHtcbiAgICBpZih0aGlzLl9tb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gSlNPTi5mcm9tU3RyaW5nKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgbGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgfVxufSJdfQ==