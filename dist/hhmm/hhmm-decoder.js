'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder <br />
 * Loads a model trained by the XMM library and processes an input stream of float vectors in real-time.
 * If the model was trained for regression, outputs an estimation of the associated process.
 * @class
 */

var HhmmDecoder = function () {

  /**
   * @param {Number} [windowSize=1] - Size of the likelihood smoothing window.
   */
  function HhmmDecoder() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * Size of the likelihood smoothing window.
     * @type {number}
     * @private
     */
    this._likelihoodWindow = windowSize;

    /**
     * The model, as generated by XMM from a training data set.
     * @type {Object}
     * @private
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter.
     * @type {Object}
     * @private
     */
    this._modelResults = undefined;
  }

  /**
   * Callback handling estimation results.
   * @callback hhmmResultsCallback
   * @param {string} err - Description of a potential error.
   * @param {hhmmResults} res - Object holding the estimation results.
   */

  /**
   * Results of the filtering process.
   * @typedef hhmmResults
   * @type {Object}
   * @name hhmmResults
   * @property {String} likeliest - The likeliest model's label.
   * @property {Number} likeliestIndex - The likeliest model's index
   * @property {Array.number} likelihoods - The array of all models' smoothed normalized likelihoods.
   * @property {Array.number} timeProgressions - The array of all models' normalized time progressions.
   * @property {Array.Array.number} alphas - The array of all models' states likelihoods array.
   * @property {?Array.number} outputValues - If the model was trained with regression, the estimated float vector output.
   * @property {?Array.number} outputCovariance - If the model was trained with regression, the output covariance matrix.
   */

  /**
   * The decoding function.
   * @param {Array.number} observation - An input float vector to be estimated.
   * @param {hhmmResultsCallback} [resultsCallback=null] - The callback handling the estimation results.
   * @returns {hhmmResults}
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation) {
      var resultsCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var err = null;
      var res = null;

      if (!this._model) {
        err = 'no model loaded yet';
      } else {
        try {
          hhmmUtils.hhmmFilter(observation, this._model, this._modelResults);

          // create results object from relevant modelResults values :
          var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: likeliest,
            likeliestIndex: this._modelResults.likeliest,
            likelihoods: likelihoods,
            timeProgressions: new Array(this._model.models.length),
            alphas: new Array(this._model.models.length),
            outputValues: [],
            outputCovariance: []
          };

          for (var i = 0; i < this._model.models.length; i++) {
            res.timeProgressions[i] = this._modelResults.singleClassHmmModelResults[i].progress;
            if (this._model.configuration.default_parameters.hierarchical) {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha_h[0];
            } else {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha[0];
            }
          }

          if (this._model.shared_parameters.bimodal) {
            res['outputValues'] = this._modelResults.output_values.slice(0);
            res['outputCovariance'] = this._modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      if (resultsCallback) {
        resultsCallback(err, res);
      }
      return res;
    }

    /**
     * Resets the intermediate results of the estimation (shortcut for reloading the model).
     */

  }, {
    key: 'reset',
    value: function reset() {
      if (this._model) {
        this._setModel(this._model);
      }
    }

    //========================== GETTERS / SETTERS =============================//

    /***
     * Likelihood smoothing window size.
     * @type {Number}
     */
    // get likelihoodWindow() {
    //   return this._likelihoodWindow;
    // }

    // set likelihoodWindow(newWindowSize) {
    //   this._likelihoodWindow = newWindowSize;
    //   this._updateLikelihoodWindow();
    // }

    /**
     * Get the likelihood smoothing window size.
     * @returns {Number}
     */

  }, {
    key: 'getLikelihoodWindow',
    value: function getLikelihoodWindow() {
      return this._likelihoodWindow;
    }

    /**
     * Set the likelihood smoothing window size.
     * @param {Number} newWindowSize - the new window size.
     */

  }, {
    key: 'setLikelihoodWindow',
    value: function setLikelihoodWindow(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      this._updateLikelihoodWindow();
    }

    /** @private */

  }, {
    key: '_updateLikelihoodWindow',
    value: function _updateLikelihoodWindow() {
      if (this._model === undefined) return;

      var res = this._modelResults.singleClassHmmModelResults;

      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);

        for (var j = 0; j < this._likelihoodWindow; j++) {
          res[i].likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }
  }, {
    key: 'setWeights',
    value: function setWeights(newWeights) {
      if (typeof newWeights !== 'array') {
        throw new Error('Weights must be an array');
      }

      this._weights = newWeights;
      this._updateWeights();
    }

    /** @private */

  }, {
    key: '_updateWeights',
    value: function _updateWeights() {
      if (this._model === undefined) return;

      var m = this._model;
      var params = m.shared_parameters;
      var dimIn = params.bimodal ? params.dimension_input : params.dimension;

      var w = this._weights.slice();

      if (w.length < dimIn) {
        for (var i = 0; i < dimIn - w.length; i++) {
          w.push(1);
        }
      } else if (w.length > dimIn) {
        w.splice(dimIn - 1);
      }

      for (var _i = 0; _i < w.length; _i++) {
        w[_i] = Math.max(w[_i], 0);
      }

      for (var _i2 = 0; _i2 < m.models.length; _i2++) {
        for (var j = 0; j < m.models[_i2].states.length; j++) {
          for (var k = 0; k < m.models[_i2].states[j].components.length; k++) {
            m.models[_i2].states[j].components[k].weights = w;
          }
        }
      }
    }

    /**
     * A valid XMM Hierarchical HMM model
     * @typedef xmmHhmmModel
     * @type {Object}
     * @name xmmHhmmModel
     * @property {String} TODO - LIST REAL HHMM MODEL PROPERTIES HERE
     */

    /***
     * The model generated by XMM.
     * It is mandatory for the class to have a model in order to do its job.
     * @type {xmmHhmmModel}
     */
    // get model() {
    //   return this.getModel();
    // }

    // set model(model) {
    //   this.setModel(model);
    // }

    /**
     * Get the actual XMM Hierarchical HMM model.
     * @returns {xmmHhmmModel}
     */

  }, {
    key: 'getModel',
    value: function getModel() {
      if (this._model) {
        return JSON.parse((0, _stringify2.default)(this._model));
      }
      return undefined;
    }

    /**
     * Set the actual XMM Hierarchical HMM model.
     * @param {xmmHhmmModel} model
     */

  }, {
    key: 'setModel',
    value: function setModel(model) {
      this._setModel(model);
    }

    /** @private */

  }, {
    key: '_setModel',
    value: function _setModel(model) {
      this._model = undefined;
      this._modelResults = undefined;

      if (!model) return;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;

        // adds user defined weights to the model (default [1, 1, ..., 1])
        this._updateWeights();

        var m = this._model;
        var nmodels = m.models.length;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);

        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          //---- full
          outCovarSize = dimOut * dimOut;
        } else {
          //------------------------------------------------------ diagonal
          outCovarSize = dimOut;
        }

        this._modelResults.output_covariance = new Array(outCovarSize);

        for (var _i3 = 0; _i3 < dimOut; _i3++) {
          this._modelResults.output_covariance[_i3] = 0.0;
        }

        for (var _i4 = 0; _i4 < nmodels; _i4++) {
          this._modelResults.instant_likelihoods[_i4] = 0;
          this._modelResults.smoothed_log_likelihoods[_i4] = 0;
          this._modelResults.smoothed_likelihoods[_i4] = 0;
          this._modelResults.instant_normalized_likelihoods[_i4] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i4] = 0;

          var nstates = m.models[_i4].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          var likelihood_buffer = new Array(this._likelihoodWindow);
          for (var _j2 = 0; _j2 < this._likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            // prior: new Array(nstates),
            // transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // aka states
          };

          hmmRes.output_values = this._modelResults.output_values.slice(0);
          hmmRes.output_covariance = this._modelResults.output_covariance.slice(0);

          // add HMM states (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this._model.models[_i4].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this._modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }
    }

    /***
     * Currently estimated likeliest label.
     * @readonly
     * @type {String}
     */
    // get likeliestLabel() {
    //   return this.getLikeliestLabel();
    // }

    /**
     * Get the currently estimated likeliest label.
     * @returns {String}
     */

  }, {
    key: 'getLikeliestLabel',
    value: function getLikeliestLabel() {
      if (this._modelResults) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }

    /***
     * Number of classes contained in the model.
     * @readonly
     * @type {Number}
     */
    // get nbClasses() {
    //   return this.getNumberOfClasses();
    // }

    /**
     * Get the total number of classes the model was trained with.
     * @returns {Number}
     */

  }, {
    key: 'getNumberOfClasses',
    value: function getNumberOfClasses() {
      if (this._model) {
        return this._model.models.length;
      }
      return 0;
    }

    /***
     * Size of the regression vector if model is bimodal.
     * @readonly
     * @type {Number}
     */
    // get regressionSize() {
    //   return this.getRegressionVectorSize();
    // }

    /**
     * Get the output dimension of the model (size of a regression vector).
     * @returns {Number}
     */

  }, {
    key: 'getRegressionVectorSize',
    value: function getRegressionVectorSize() {
      if (this._model) {
        var params = this._model.shared_parameters;
        return params['bimodal'] ? params['dimension'] - params['dimension_input'] : 0;
      }
      return 0;
    }
  }]);
  return HhmmDecoder;
}();

;

exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhobW0tZGVjb2Rlci5qcyJdLCJuYW1lcyI6WyJoaG1tVXRpbHMiLCJIaG1tRGVjb2RlciIsIndpbmRvd1NpemUiLCJfbGlrZWxpaG9vZFdpbmRvdyIsIl9tb2RlbCIsInVuZGVmaW5lZCIsIl9tb2RlbFJlc3VsdHMiLCJvYnNlcnZhdGlvbiIsInJlc3VsdHNDYWxsYmFjayIsImVyciIsInJlcyIsImhobW1GaWx0ZXIiLCJsaWtlbGllc3QiLCJtb2RlbHMiLCJsYWJlbCIsImxpa2VsaWhvb2RzIiwic21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcyIsInNsaWNlIiwibGlrZWxpZXN0SW5kZXgiLCJ0aW1lUHJvZ3Jlc3Npb25zIiwiQXJyYXkiLCJsZW5ndGgiLCJhbHBoYXMiLCJvdXRwdXRWYWx1ZXMiLCJvdXRwdXRDb3ZhcmlhbmNlIiwiaSIsInNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzIiwicHJvZ3Jlc3MiLCJjb25maWd1cmF0aW9uIiwiZGVmYXVsdF9wYXJhbWV0ZXJzIiwiaGllcmFyY2hpY2FsIiwiYWxwaGFfaCIsImFscGhhIiwic2hhcmVkX3BhcmFtZXRlcnMiLCJiaW1vZGFsIiwib3V0cHV0X3ZhbHVlcyIsIm91dHB1dF9jb3ZhcmlhbmNlIiwiZSIsIl9zZXRNb2RlbCIsIm5ld1dpbmRvd1NpemUiLCJfdXBkYXRlTGlrZWxpaG9vZFdpbmRvdyIsImxpa2VsaWhvb2RfYnVmZmVyIiwiaiIsIm5ld1dlaWdodHMiLCJFcnJvciIsIl93ZWlnaHRzIiwiX3VwZGF0ZVdlaWdodHMiLCJtIiwicGFyYW1zIiwiZGltSW4iLCJkaW1lbnNpb25faW5wdXQiLCJkaW1lbnNpb24iLCJ3IiwicHVzaCIsInNwbGljZSIsIk1hdGgiLCJtYXgiLCJzdGF0ZXMiLCJrIiwiY29tcG9uZW50cyIsIndlaWdodHMiLCJKU09OIiwicGFyc2UiLCJtb2RlbCIsIm5tb2RlbHMiLCJpbnN0YW50X2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbGlrZWxpaG9vZHMiLCJpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMiLCJmcm9udGllcl92MSIsImZyb250aWVyX3YyIiwiZm9yd2FyZF9pbml0aWFsaXplZCIsImRpbU91dCIsIm91dENvdmFyU2l6ZSIsImNvdmFyaWFuY2VfbW9kZSIsIm5zdGF0ZXMiLCJwYXJhbWV0ZXJzIiwiaG1tUmVzIiwiaW5zdGFudF9saWtlbGlob29kIiwibG9nX2xpa2VsaWhvb2QiLCJsaWtlbGlob29kX2J1ZmZlcl9pbmRleCIsImV4aXRfbGlrZWxpaG9vZCIsImV4aXRfcmF0aW8iLCJsaWtlbGllc3Rfc3RhdGUiLCJwcmV2aW91c19hbHBoYSIsIndpbmRvd19taW5pbmRleCIsIndpbmRvd19tYXhpbmRleCIsIndpbmRvd19ub3JtYWxpemF0aW9uX2NvbnN0YW50Iiwic2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHMiLCJnbW1SZXMiLCJiZXRhIiwiZ2F1c3NpYW5zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7SUFBWUEsUzs7Ozs7O0FBRVo7Ozs7Ozs7SUFPTUMsVzs7QUFFSjs7O0FBR0EseUJBQTRCO0FBQUEsUUFBaEJDLFVBQWdCLHVFQUFILENBQUc7QUFBQTs7O0FBRTFCOzs7OztBQUtBLFNBQUtDLGlCQUFMLEdBQXlCRCxVQUF6Qjs7QUFFQTs7Ozs7QUFLQSxTQUFLRSxNQUFMLEdBQWNDLFNBQWQ7O0FBRUE7Ozs7O0FBS0EsU0FBS0MsYUFBTCxHQUFxQkQsU0FBckI7QUFDRDs7QUFFRDs7Ozs7OztBQU9BOzs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7OzJCQU1PRSxXLEVBQXFDO0FBQUEsVUFBeEJDLGVBQXdCLHVFQUFOLElBQU07O0FBQzFDLFVBQUlDLE1BQU0sSUFBVjtBQUNBLFVBQUlDLE1BQU0sSUFBVjs7QUFFQSxVQUFHLENBQUMsS0FBS04sTUFBVCxFQUFpQjtBQUNmSyxjQUFNLHFCQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsWUFBSTtBQUNGVCxvQkFBVVcs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QW5CLENBQThDMkIsSUFBOUMsQ0FBbUR3QixNQUFuRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7d0NBSW9CO0FBQ2xCLFVBQUksS0FBS3ZFLGFBQVQsRUFBd0I7QUFDdEIsWUFBSSxLQUFLQSxhQUFMLENBQW1CTSxTQUFuQixHQUErQixDQUFDLENBQXBDLEVBQXVDO0FBQ3JDLGlCQUFPLEtBQUtSLE1BQUwsQ0FBWVMsTUFBWixDQUFtQixLQUFLUCxhQUFMLENBQW1CTSxTQUF0QyxFQUFpREUsS0FBeEQ7QUFDRDtBQUNGO0FBQ0QsYUFBTyxTQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O3lDQUlxQjtBQUNuQixVQUFJLEtBQUtWLE1BQVQsRUFBaUI7QUFDZixlQUFPLEtBQUtBLE1BQUwsQ0FBWVMsTUFBWixDQUFtQlEsTUFBMUI7QUFDRDtBQUNELGFBQU8sQ0FBUDtBQUNEOztBQUVEOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs4Q0FJMEI7QUFDeEIsVUFBSSxLQUFLakIsTUFBVCxFQUFpQjtBQUNmLFlBQU00QyxTQUFTLEtBQUs1QyxNQUFMLENBQVk2QixpQkFBM0I7QUFDQSxlQUFPZSxPQUFPLFNBQVAsSUFDQUEsT0FBTyxXQUFQLElBQXNCQSxPQUFPLGlCQUFQLENBRHRCLEdBRUEsQ0FGUDtBQUdEO0FBQ0QsYUFBTyxDQUFQO0FBQ0Q7Ozs7O0FBQ0Y7O2tCQUVjL0MsVyIsImZpbGUiOiJoaG1tLWRlY29kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBoaG1tVXRpbHMgZnJvbSAnLi4vdXRpbHMvaGhtbS11dGlscyc7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIEhNTSBkZWNvZGVyIDxiciAvPlxuICogTG9hZHMgYSBtb2RlbCB0cmFpbmVkIGJ5IHRoZSBYTU0gbGlicmFyeSBhbmQgcHJvY2Vzc2VzIGFuIGlucHV0IHN0cmVhbSBvZiBmbG9hdCB2ZWN0b3JzIGluIHJlYWwtdGltZS5cbiAqIElmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCBmb3IgcmVncmVzc2lvbiwgb3V0cHV0cyBhbiBlc3RpbWF0aW9uIG9mIHRoZSBhc3NvY2lhdGVkIHByb2Nlc3MuXG4gKiBAY2xhc3NcbiAqL1xuXG5jbGFzcyBIaG1tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZT0xXSAtIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSB3aW5kb3dTaXplO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgcmVzdWx0cywgY29udGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBpbiBmaWx0ZXIuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEBjYWxsYmFjayBoaG1tUmVzdWx0c0NhbGxiYWNrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnIgLSBEZXNjcmlwdGlvbiBvZiBhIHBvdGVudGlhbCBlcnJvci5cbiAgICogQHBhcmFtIHtoaG1tUmVzdWx0c30gcmVzIC0gT2JqZWN0IGhvbGRpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFJlc3VsdHMgb2YgdGhlIGZpbHRlcmluZyBwcm9jZXNzLlxuICAgKiBAdHlwZWRlZiBoaG1tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAbmFtZSBoaG1tUmVzdWx0c1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbGlrZWxpZXN0IC0gVGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbGlrZWxpZXN0SW5kZXggLSBUaGUgbGlrZWxpZXN0IG1vZGVsJ3MgaW5kZXhcbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IGxpa2VsaWhvb2RzIC0gVGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIHNtb290aGVkIG5vcm1hbGl6ZWQgbGlrZWxpaG9vZHMuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSB0aW1lUHJvZ3Jlc3Npb25zIC0gVGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIG5vcm1hbGl6ZWQgdGltZSBwcm9ncmVzc2lvbnMuXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkuQXJyYXkubnVtYmVyfSBhbHBoYXMgLSBUaGUgYXJyYXkgb2YgYWxsIG1vZGVscycgc3RhdGVzIGxpa2VsaWhvb2RzIGFycmF5LlxuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dFZhbHVlcyAtIElmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoIHJlZ3Jlc3Npb24sIHRoZSBlc3RpbWF0ZWQgZmxvYXQgdmVjdG9yIG91dHB1dC5cbiAgICogQHByb3BlcnR5IHs/QXJyYXkubnVtYmVyfSBvdXRwdXRDb3ZhcmlhbmNlIC0gSWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIG91dHB1dCBjb3ZhcmlhbmNlIG1hdHJpeC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBkZWNvZGluZyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheS5udW1iZXJ9IG9ic2VydmF0aW9uIC0gQW4gaW5wdXQgZmxvYXQgdmVjdG9yIHRvIGJlIGVzdGltYXRlZC5cbiAgICogQHBhcmFtIHtoaG1tUmVzdWx0c0NhbGxiYWNrfSBbcmVzdWx0c0NhbGxiYWNrPW51bGxdIC0gVGhlIGNhbGxiYWNrIGhhbmRsaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEByZXR1cm5zIHtoaG1tUmVzdWx0c31cbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrID0gbnVsbCkge1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCByZXMgPSBudWxsO1xuXG4gICAgaWYoIXRoaXMuX21vZGVsKSB7XG4gICAgICBlcnIgPSAnbm8gbW9kZWwgbG9hZGVkIHlldCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhobW1VdGlscy5oaG1tRmlsdGVyKG9ic2VydmF0aW9uLCB0aGlzLl9tb2RlbCwgdGhpcy5fbW9kZWxSZXN1bHRzKTtcblxuICAgICAgICAvLyBjcmVhdGUgcmVzdWx0cyBvYmplY3QgZnJvbSByZWxldmFudCBtb2RlbFJlc3VsdHMgdmFsdWVzIDpcbiAgICAgICAgY29uc3QgbGlrZWxpZXN0ID0gKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5fbW9kZWwubW9kZWxzW3RoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICd1bmtub3duJztcbiAgICAgICAgY29uc3QgbGlrZWxpaG9vZHMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcy5zbGljZSgwKTtcbiAgICAgICAgcmVzID0ge1xuICAgICAgICAgIGxpa2VsaWVzdDogbGlrZWxpZXN0LFxuICAgICAgICAgIGxpa2VsaWVzdEluZGV4OiB0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0LFxuICAgICAgICAgIGxpa2VsaWhvb2RzOiBsaWtlbGlob29kcyxcbiAgICAgICAgICB0aW1lUHJvZ3Jlc3Npb25zOiBuZXcgQXJyYXkodGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aCksXG4gICAgICAgICAgYWxwaGFzOiBuZXcgQXJyYXkodGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aCksXG4gICAgICAgICAgb3V0cHV0VmFsdWVzOiBbXSxcbiAgICAgICAgICBvdXRwdXRDb3ZhcmlhbmNlOiBbXSxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlcy50aW1lUHJvZ3Jlc3Npb25zW2ldID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzW2ldLnByb2dyZXNzO1xuICAgICAgICAgIGlmICh0aGlzLl9tb2RlbC5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5oaWVyYXJjaGljYWwpIHtcbiAgICAgICAgICAgIHJlcy5hbHBoYXNbaV1cbiAgICAgICAgICAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0uYWxwaGFfaFswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLmFscGhhc1tpXVxuICAgICAgICAgICAgICA9IHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0c1tpXS5hbHBoYVswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbW9kZWwuc2hhcmVkX3BhcmFtZXRlcnMuYmltb2RhbCkge1xuICAgICAgICAgIHJlc1snb3V0cHV0VmFsdWVzJ10gPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgICByZXNbJ291dHB1dENvdmFyaWFuY2UnXVxuICAgICAgICAgICAgICA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnIgPSAncHJvYmxlbSBvY2N1cmVkIGR1cmluZyBmaWx0ZXJpbmcgOiAnICsgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0c0NhbGxiYWNrKSB7XG4gICAgICByZXN1bHRzQ2FsbGJhY2soZXJyLCByZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgb2YgdGhlIGVzdGltYXRpb24gKHNob3J0Y3V0IGZvciByZWxvYWRpbmcgdGhlIG1vZGVsKS5cbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCkge1xuICAgICAgdGhpcy5fc2V0TW9kZWwodGhpcy5fbW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT0gR0VUVEVSUyAvIFNFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKipcbiAgICogTGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93IHNpemUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICAvLyBnZXQgbGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgLy8gfVxuXG4gIC8vIHNldCBsaWtlbGlob29kV2luZG93KG5ld1dpbmRvd1NpemUpIHtcbiAgLy8gICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gbmV3V2luZG93U2l6ZTtcbiAgLy8gICB0aGlzLl91cGRhdGVMaWtlbGlob29kV2luZG93KCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldExpa2VsaWhvb2RXaW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpbmRvd1NpemUgLSB0aGUgbmV3IHdpbmRvdyBzaXplLlxuICAgKi9cbiAgc2V0TGlrZWxpaG9vZFdpbmRvdyhuZXdXaW5kb3dTaXplKSB7XG4gICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IG5ld1dpbmRvd1NpemU7XG4gICAgdGhpcy5fdXBkYXRlTGlrZWxpaG9vZFdpbmRvdygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF91cGRhdGVMaWtlbGlob29kV2luZG93KCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBjb25zdCByZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHM7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXS5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICB9XG4gICAgfSAgICBcbiAgfVxuXG4gIHNldFdlaWdodHMobmV3V2VpZ2h0cykge1xuICAgIGlmICh0eXBlb2YobmV3V2VpZ2h0cykgIT09ICdhcnJheScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2VpZ2h0cyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2VpZ2h0cyA9IG5ld1dlaWdodHM7XG4gICAgdGhpcy5fdXBkYXRlV2VpZ2h0cygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF91cGRhdGVXZWlnaHRzKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBjb25zdCBtID0gdGhpcy5fbW9kZWw7XG4gICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICBjb25zdCBkaW1JbiA9IHBhcmFtcy5iaW1vZGFsID8gcGFyYW1zLmRpbWVuc2lvbl9pbnB1dCA6IHBhcmFtcy5kaW1lbnNpb247XG5cbiAgICBjb25zdCB3ID0gdGhpcy5fd2VpZ2h0cy5zbGljZSgpO1xuXG4gICAgaWYgKHcubGVuZ3RoIDwgZGltSW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltSW4gLSB3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHcucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHcubGVuZ3RoID4gZGltSW4pIHtcbiAgICAgIHcuc3BsaWNlKGRpbUluIC0gMSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB3W2ldID0gTWF0aC5tYXgod1tpXSwgMCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtLm1vZGVsc1tpXS5zdGF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBtLm1vZGVsc1tpXS5zdGF0ZXNbal0uY29tcG9uZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIG0ubW9kZWxzW2ldLnN0YXRlc1tqXS5jb21wb25lbnRzW2tdLndlaWdodHMgPSB3O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgdmFsaWQgWE1NIEhpZXJhcmNoaWNhbCBITU0gbW9kZWxcbiAgICogQHR5cGVkZWYgeG1tSGhtbU1vZGVsXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBuYW1lIHhtbUhobW1Nb2RlbFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gVE9ETyAtIExJU1QgUkVBTCBISE1NIE1PREVMIFBST1BFUlRJRVMgSEVSRVxuICAgKi9cblxuICAvKioqXG4gICAqIFRoZSBtb2RlbCBnZW5lcmF0ZWQgYnkgWE1NLlxuICAgKiBJdCBpcyBtYW5kYXRvcnkgZm9yIHRoZSBjbGFzcyB0byBoYXZlIGEgbW9kZWwgaW4gb3JkZXIgdG8gZG8gaXRzIGpvYi5cbiAgICogQHR5cGUge3htbUhobW1Nb2RlbH1cbiAgICovXG4gIC8vIGdldCBtb2RlbCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRNb2RlbCgpO1xuICAvLyB9XG5cbiAgLy8gc2V0IG1vZGVsKG1vZGVsKSB7XG4gIC8vICAgdGhpcy5zZXRNb2RlbChtb2RlbCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhY3R1YWwgWE1NIEhpZXJhcmNoaWNhbCBITU0gbW9kZWwuXG4gICAqIEByZXR1cm5zIHt4bW1IaG1tTW9kZWx9XG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7ICAgIFxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYWN0dWFsIFhNTSBIaWVyYXJjaGljYWwgSE1NIG1vZGVsLlxuICAgKiBAcGFyYW0ge3htbUhobW1Nb2RlbH0gbW9kZWxcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5fc2V0TW9kZWwobW9kZWwpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9zZXRNb2RlbChtb2RlbCkgeyAgICAgIFxuICAgIHRoaXMuX21vZGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICghbW9kZWwpIHJldHVybjtcblxuICAgIC8vIHRlc3QgaWYgbW9kZWwgaXMgdmFsaWQgaGVyZSAoVE9ETyA6IHdyaXRlIGEgYmV0dGVyIHRlc3QpXG4gICAgaWYgKG1vZGVsLm1vZGVscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuXG4gICAgICAvLyBhZGRzIHVzZXIgZGVmaW5lZCB3ZWlnaHRzIHRvIHRoZSBtb2RlbCAoZGVmYXVsdCBbMSwgMSwgLi4uLCAxXSlcbiAgICAgIHRoaXMuX3VwZGF0ZVdlaWdodHMoKTtcblxuICAgICAgY29uc3QgbSA9IHRoaXMuX21vZGVsO1xuICAgICAgY29uc3Qgbm1vZGVscyA9IG0ubW9kZWxzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzID0ge1xuICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xvZ19saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBsaWtlbGllc3Q6IC0xLFxuICAgICAgICBmcm9udGllcl92MTogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBmcm9udGllcl92MjogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBmb3J3YXJkX2luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHM6IFtdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBtLnNoYXJlZF9wYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgZGltT3V0ID0gcGFyYW1zLmRpbWVuc2lvbiAtIHBhcmFtcy5kaW1lbnNpb25faW5wdXQ7XG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcyA9IG5ldyBBcnJheShkaW1PdXQpO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzW2ldID0gMC4wO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0Q292YXJTaXplO1xuICAgICAgaWYgKG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuY292YXJpYW5jZV9tb2RlID09IDApIHsgLy8tLS0tIGZ1bGxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0ICogZGltT3V0O1xuICAgICAgfSBlbHNlIHsgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGlhZ29uYWxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2VbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm1vZGVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgbnN0YXRlcyA9IG0ubW9kZWxzW2ldLnBhcmFtZXRlcnMuc3RhdGVzO1xuXG4gICAgICAgIGNvbnN0IGFscGhhX2ggPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgYWxwaGFfaFtqXSA9IG5ldyBBcnJheShuc3RhdGVzKTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5zdGF0ZXM7IGsrKykge1xuICAgICAgICAgICAgYWxwaGFfaFtqXVtrXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhbHBoYSA9IG5ldyBBcnJheShuc3RhdGVzKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuc3RhdGVzOyBqKyspIHtcbiAgICAgICAgICBhbHBoYVtqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdzsgaisrKSB7XG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXJbal0gPSAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBobW1SZXMgPSB7XG4gICAgICAgICAgaGllcmFyY2hpY2FsOiBtLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmhpZXJhcmNoaWNhbCxcbiAgICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2Q6IDAsXG4gICAgICAgICAgbG9nX2xpa2VsaWhvb2Q6IDAsXG4gICAgICAgICAgLy8gZm9yIGNpcmN1bGFyIGJ1ZmZlciBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIC8vIChzZWUgaG1tVXBkYXRlUmVzdWx0cykgOlxuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyOiBsaWtlbGlob29kX2J1ZmZlcixcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcl9pbmRleDogMCxcbiAgICAgICAgICBwcm9ncmVzczogMCxcblxuICAgICAgICAgIGV4aXRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBleGl0X3JhdGlvOiAwLFxuXG4gICAgICAgICAgbGlrZWxpZXN0X3N0YXRlOiAtMSxcblxuICAgICAgICAgIC8vIGZvciBub24taGllcmFyY2hpY2FsIDpcbiAgICAgICAgICBwcmV2aW91c19hbHBoYTogYWxwaGEuc2xpY2UoMCksXG4gICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICAgIC8vIGZvciBoaWVyYXJjaGljYWwgOiAgICAgICBcbiAgICAgICAgICBhbHBoYV9oOiBhbHBoYV9oLFxuICAgICAgICAgIC8vIHByaW9yOiBuZXcgQXJyYXkobnN0YXRlcyksXG4gICAgICAgICAgLy8gdHJhbnNpdGlvbjogbmV3IEFycmF5KG5zdGF0ZXMpLFxuXG4gICAgICAgICAgLy8gdXNlZCBpbiBobW1VcGRhdGVBbHBoYVdpbmRvd1xuICAgICAgICAgIHdpbmRvd19taW5pbmRleDogMCxcbiAgICAgICAgICB3aW5kb3dfbWF4aW5kZXg6IDAsXG4gICAgICAgICAgd2luZG93X25vcm1hbGl6YXRpb25fY29uc3RhbnQ6IDAsXG5cbiAgICAgICAgICAvLyBmb3Igbm9uLWhpZXJhcmNoaWNhbCBtb2RlXG4gICAgICAgICAgZm9yd2FyZF9pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgXG4gICAgICAgICAgc2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHM6IFtdICAvLyBha2Egc3RhdGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaG1tUmVzLm91dHB1dF92YWx1ZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgaG1tUmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIGFkZCBITU0gc3RhdGVzIChHTU1zKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5zdGF0ZXM7IGorKykge1xuICAgICAgICAgIGNvbnN0IGdtbVJlcyA9IHtcbiAgICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbW1SZXMuYmV0YSA9IG5ldyBBcnJheSh0aGlzLl9tb2RlbC5tb2RlbHNbaV0ucGFyYW1ldGVycy5nYXVzc2lhbnMpO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZ21tUmVzLmJldGEubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGdtbVJlcy5iZXRhW2tdID0gMSAvIGdtbVJlcy5iZXRhLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ21tUmVzLm91dHB1dF92YWx1ZXMgPSBobW1SZXMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgICBnbW1SZXMub3V0cHV0X2NvdmFyaWFuY2UgPSBobW1SZXMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG5cbiAgICAgICAgICBobW1SZXMuc2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHMucHVzaChnbW1SZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzLnB1c2goaG1tUmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIEN1cnJlbnRseSBlc3RpbWF0ZWQgbGlrZWxpZXN0IGxhYmVsLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIC8vIGdldCBsaWtlbGllc3RMYWJlbCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRMaWtlbGllc3RMYWJlbCgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGVzdGltYXRlZCBsaWtlbGllc3QgbGFiZWwuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRMaWtlbGllc3RMYWJlbCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWxSZXN1bHRzKSB7XG4gICAgICBpZiAodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7ICAgIFxuICB9XG5cbiAgLyoqKlxuICAgKiBOdW1iZXIgb2YgY2xhc3NlcyBjb250YWluZWQgaW4gdGhlIG1vZGVsLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIC8vIGdldCBuYkNsYXNzZXMoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyT2ZDbGFzc2VzKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b3RhbCBudW1iZXIgb2YgY2xhc3NlcyB0aGUgbW9kZWwgd2FzIHRyYWluZWQgd2l0aC5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldE51bWJlck9mQ2xhc3NlcygpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKipcbiAgICogU2l6ZSBvZiB0aGUgcmVncmVzc2lvbiB2ZWN0b3IgaWYgbW9kZWwgaXMgYmltb2RhbC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICAvLyBnZXQgcmVncmVzc2lvblNpemUoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZ2V0UmVncmVzc2lvblZlY3RvclNpemUoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBkaW1lbnNpb24gb2YgdGhlIG1vZGVsIChzaXplIG9mIGEgcmVncmVzc2lvbiB2ZWN0b3IpLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVncmVzc2lvblZlY3RvclNpemUoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIHJldHVybiBwYXJhbXNbJ2JpbW9kYWwnXVxuICAgICAgICAgICA/IHBhcmFtc1snZGltZW5zaW9uJ10gLSBwYXJhbXNbJ2RpbWVuc2lvbl9pbnB1dCddXG4gICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhobW1EZWNvZGVyOyJdfQ==