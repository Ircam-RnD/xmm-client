'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vectors in real-time
 * if the model was trained for regression, outputs an estimation
 * @class
 */

var HhmmDecoder = function () {

  /**
   * @param {number} windowSize - size of the likelihood smoothing window
   */
  function HhmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * Size of the likelihood smoothing window
     * @type {number}
     */
    this._likelihoodWindow = windowSize;

    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter
     * @type {Object}
     */
    this._modelResults = undefined;
  }

  /**
   * @typedef HhmmResults
   * @type {Object}
   * @property {string} likeliest - the likeliest model's label
   * @property {Array.number} likelihoods - the array of all models' normalized likelihoods
   * @property {Array.number} timeProgressions - the array of all models' normalized time progressions
   * @property {Array.Array.number} alphas - the array of all models' states likelihoods array
   * @property {?Array.number} outputValues - if the model was trained with regression, the estimated float vector output
   */

  /**
   * Callback handling estimation results
   * @callback ResultsCallback
   * @param {string} err - description of a potential error
   * @param {HhmmResults} res - object holding the estimation results
   */

  /**
   * The decoding function
   * @param {Array.number} observation - an input float vector to be estimated
   * @param {ResultsCallback} resultsCallback - the callback handling the estimation results
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      var err = null;
      var res = null;

      if (this._model === undefined) {
        err = 'no model loaded yet';
      } else {
        try {
          hhmmUtils.hhmmFilter(observation, this._model, this._modelResults);

          // create results object from relevant modelResults values :

          var lklst = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var lklhds = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: lklst,
            likelihoods: lklhds,
            alphas: new Array(this._model.models.length)
          };

          for (var i = 0; i < this._model.models.length; i++) {
            if (this._model.configuration.default_parameters.hierarchical) {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha_h[0];
            } else {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha[0];
            }
          }

          if (this._model.shared_parameters.bimodal) {
            res.outputValues = this._modelResults.output_values.slice(0);
            // results.outputCovariance
            //     = this._modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      resultsCallback(err, res);
    }

    /**
     * Resets the intermediate results of the estimation
     */

  }, {
    key: 'reset',
    value: function reset() {
      /** @todo : write a real reset (see c++ version) */
      this._modelResults.forward_initialized = false;
    }

    // ==================== SETTERS ====================== //

    /**
     * The model generated by XMM
     * It is mandatory for the class to have a model in order to do its job
     * @type {Object}
     */

  }, {
    key: 'model',
    set: function set(model) {

      this._model = undefined;
      this._modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {

        //console.log(model);

        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;

        // not used anymore (returns a more complex js object)
        // const nstatesGlobal = m.configuration.default_parameters.states;
        // this.params.frameSize = nstatesGlobal;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        // move output_values / output_covariance here for regression
        // and dupe (.slice(0)) them in sub-modelResults
        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          // full
          outCovarSize = dimOut * dimOut;
        } else {
          // diagonal
          outCovarSize = dimOut;
        }
        this._modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var nstates = m.models[_i2].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          // const winSize = m.shared_parameters.likelihood_window
          // let likelihood_buffer = new Array(winSize);
          var likelihood_buffer = new Array(this._likelihoodWindow);
          for (var _j2 = 0; _j2 < this._likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            prior: new Array(nstates),
            transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // states
          };

          hmmRes.output_values = this._modelResults.output_values.slice(0);
          hmmRes.output_covariance = this._modelResults.output_covariance.slice(0);

          // add HMM states (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this._model.models[_i2].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this._modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }
    },
    get: function get() {
      if (this._model !== undefined) {
        return JSON.fromString((0, _stringify2.default)(this._model));
      }
      return undefined;
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      if (this._model === undefined) return;
      var res = this._modelResults.singleClassModelResults;
      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);
        for (var j = 0; j < this._likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    // ==================== GETTERS ====================== //

    ,
    get: function get() {
      return this._likelihoodWindow;
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this._modelResults !== undefined) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
      //return('no estimation available');
    }
  }, {
    key: 'nbClasses',
    get: function get() {
      if (this._model !== undefined) {
        return this._model.models.length;
      }
      return 0;
    }
  }]);
  return HhmmDecoder;
}(); //import * as gmmUtils from '../utils/gmm-utils';


exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhobW0tZGVjb2Rlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTs7SUFBWSxTOzs7Ozs7QUFFWjs7Ozs7OztJQU9xQixXOztBQUVuQjs7O0FBR0EseUJBQTRCO0FBQUEsUUFBaEIsVUFBZ0IseURBQUgsQ0FBRztBQUFBOzs7QUFFMUI7Ozs7QUFJQSxTQUFLLGlCQUFMLEdBQXlCLFVBQXpCOztBQUVBOzs7O0FBSUEsU0FBSyxNQUFMLEdBQWMsU0FBZDs7QUFFQTs7OztBQUlBLFNBQUssYUFBTCxHQUFxQixTQUFyQjtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7QUFPQTs7Ozs7Ozs7OzJCQUtPLFcsRUFBYSxlLEVBQWlCO0FBQ25DLFVBQUksTUFBTSxJQUFWO0FBQ0EsVUFBSSxNQUFNLElBQVY7O0FBRUEsVUFBRyxLQUFLLE1BQUwsS0FBZ0IsU0FBbkIsRUFBOEI7QUFDNUIsY0FBTSxxQkFBTjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUk7QUFDRixvQkFBVSxVQUFWLENBQXFCLFdBQXJCLEVBQWtDLEtBQUssTUFBdkMsRUFBK0MsS0FBSyxhQUFwRDs7QUFFQTs7QUFFQSxjQUFNLFFBQVMsS0FBSyxhQUFMLENBQW1CLFNBQW5CLEdBQStCLENBQUMsQ0FBakMsR0FDQSxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQUssYUFBTCxDQUFtQixTQUF0QyxFQUFpRCxLQURqRCxHQUVBLFNBRmQ7QUFHQSxjQUFNLFNBQVMsS0FBSyxhQUFMLENBQW1CLCtCQUFuQixDQUFtRCxLQUFuRCxDQUF5RCxDQUF6RCxDQUFmO0FBQ0EsZ0JBQU07QUFDSix1QkFBVyxLQURQO0FBRUoseUJBQWEsTUFGVDtBQUdKLG9CQUFRLElBQUksS0FBSixDQUFVLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBN0I7QUFISixXQUFOOztBQU1BLGVBQUksSUFBSSxJQUFJLENBQVosRUFBZSxJQUFJLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBdEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDakQsZ0JBQUcsS0FBSyxNQUFMLENBQVksYUFBWixDQUEwQixrQkFBMUIsQ0FBNkMsWUFBaEQsRUFBOEQ7QUFDNUQsa0JBQUksTUFBSixDQUFXLENBQVgsSUFDSSxLQUFLLGFBQUwsQ0FBbUIsMEJBQW5CLENBQThDLENBQTlDLEVBQWlELE9BQWpELENBQXlELENBQXpELENBREo7QUFFRCxhQUhELE1BR087QUFDTCxrQkFBSSxNQUFKLENBQVcsQ0FBWCxJQUNJLEtBQUssYUFBTCxDQUFtQiwwQkFBbkIsQ0FBOEMsQ0FBOUMsRUFBaUQsS0FBakQsQ0FBdUQsQ0FBdkQsQ0FESjtBQUVEO0FBQ0Y7O0FBRUQsY0FBRyxLQUFLLE1BQUwsQ0FBWSxpQkFBWixDQUE4QixPQUFqQyxFQUEwQztBQUN4QyxnQkFBSSxZQUFKLEdBQW1CLEtBQUssYUFBTCxDQUFtQixhQUFuQixDQUFpQyxLQUFqQyxDQUF1QyxDQUF2QyxDQUFuQjtBQUNBO0FBQ0E7QUFDRDtBQUNGLFNBOUJELENBOEJFLE9BQU8sQ0FBUCxFQUFVO0FBQ1YsZ0JBQU0sd0NBQXdDLENBQTlDO0FBQ0Q7QUFDRjs7QUFFRCxzQkFBZ0IsR0FBaEIsRUFBcUIsR0FBckI7QUFDRDs7QUFFRDs7Ozs7OzRCQUdRO0FBQ047QUFDQSxXQUFLLGFBQUwsQ0FBbUIsbUJBQW5CLEdBQXlDLEtBQXpDO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7O3NCQUtVLEssRUFBTzs7QUFFZixXQUFLLE1BQUwsR0FBYyxTQUFkO0FBQ0EsV0FBSyxhQUFMLEdBQXFCLFNBQXJCOztBQUVBO0FBQ0EsVUFBRyxNQUFNLE1BQU4sS0FBaUIsU0FBcEIsRUFBK0I7O0FBRTdCOztBQUVBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxZQUFNLElBQUksS0FBSyxNQUFmO0FBQ0EsWUFBTSxVQUFVLEVBQUUsTUFBRixDQUFTLE1BQXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFLLGFBQUwsR0FBcUI7QUFDbkIsK0JBQXFCLElBQUksS0FBSixDQUFVLE9BQVYsQ0FERjtBQUVuQixvQ0FBMEIsSUFBSSxLQUFKLENBQVUsT0FBVixDQUZQO0FBR25CLGdDQUFzQixJQUFJLEtBQUosQ0FBVSxPQUFWLENBSEg7QUFJbkIsMENBQWdDLElBQUksS0FBSixDQUFVLE9BQVYsQ0FKYjtBQUtuQiwyQ0FBaUMsSUFBSSxLQUFKLENBQVUsT0FBVixDQUxkO0FBTW5CLHFCQUFXLENBQUMsQ0FOTztBQU9uQix1QkFBYSxJQUFJLEtBQUosQ0FBVSxPQUFWLENBUE07QUFRbkIsdUJBQWEsSUFBSSxLQUFKLENBQVUsT0FBVixDQVJNO0FBU25CLCtCQUFxQixLQVRGO0FBVW5CLHNDQUE0QjtBQVZULFNBQXJCOztBQWFBO0FBQ0E7QUFDQSxZQUFNLFNBQVMsRUFBRSxpQkFBakI7QUFDQSxZQUFNLFNBQVMsT0FBTyxTQUFQLEdBQW1CLE9BQU8sZUFBekM7QUFDQSxhQUFLLGFBQUwsQ0FBbUIsYUFBbkIsR0FBbUMsSUFBSSxLQUFKLENBQVUsTUFBVixDQUFuQztBQUNBLGFBQUksSUFBSSxJQUFJLENBQVosRUFBZSxJQUFJLE1BQW5CLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzlCLGVBQUssYUFBTCxDQUFtQixhQUFuQixDQUFpQyxDQUFqQyxJQUFzQyxHQUF0QztBQUNEOztBQUVELFlBQUkscUJBQUo7QUFDQSxZQUFHLEVBQUUsYUFBRixDQUFnQixrQkFBaEIsQ0FBbUMsZUFBbkMsSUFBc0QsQ0FBekQsRUFBNEQ7QUFBRTtBQUM1RCx5QkFBZSxTQUFTLE1BQXhCO0FBQ0QsU0FGRCxNQUdLO0FBQUU7QUFDTCx5QkFBZSxNQUFmO0FBQ0Q7QUFDRCxhQUFLLGFBQUwsQ0FBbUIsaUJBQW5CLEdBQXVDLElBQUksS0FBSixDQUFVLFlBQVYsQ0FBdkM7QUFDQSxhQUFJLElBQUksS0FBSSxDQUFaLEVBQWUsS0FBSSxNQUFuQixFQUEyQixJQUEzQixFQUFnQztBQUM5QixlQUFLLGFBQUwsQ0FBbUIsaUJBQW5CLENBQXFDLEVBQXJDLElBQTBDLEdBQTFDO0FBQ0Q7O0FBRUQsYUFBSSxJQUFJLE1BQUksQ0FBWixFQUFlLE1BQUksT0FBbkIsRUFBNEIsS0FBNUIsRUFBaUM7O0FBRS9CLGVBQUssYUFBTCxDQUFtQixtQkFBbkIsQ0FBdUMsR0FBdkMsSUFBNEMsQ0FBNUM7QUFDQSxlQUFLLGFBQUwsQ0FBbUIsd0JBQW5CLENBQTRDLEdBQTVDLElBQWlELENBQWpEO0FBQ0EsZUFBSyxhQUFMLENBQW1CLG9CQUFuQixDQUF3QyxHQUF4QyxJQUE2QyxDQUE3QztBQUNBLGVBQUssYUFBTCxDQUFtQiw4QkFBbkIsQ0FBa0QsR0FBbEQsSUFBdUQsQ0FBdkQ7QUFDQSxlQUFLLGFBQUwsQ0FBbUIsK0JBQW5CLENBQW1ELEdBQW5ELElBQXdELENBQXhEOztBQUVBLGNBQU0sVUFBVSxFQUFFLE1BQUYsQ0FBUyxHQUFULEVBQVksVUFBWixDQUF1QixNQUF2Qzs7QUFFQSxjQUFNLFVBQVUsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUFoQjtBQUNBLGVBQUksSUFBSSxJQUFFLENBQVYsRUFBYSxJQUFFLENBQWYsRUFBa0IsR0FBbEIsRUFBdUI7QUFDckIsb0JBQVEsQ0FBUixJQUFhLElBQUksS0FBSixDQUFVLE9BQVYsQ0FBYjtBQUNBLGlCQUFJLElBQUksSUFBRSxDQUFWLEVBQWEsSUFBRSxPQUFmLEVBQXdCLEdBQXhCLEVBQTZCO0FBQzNCLHNCQUFRLENBQVIsRUFBVyxDQUFYLElBQWdCLENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxjQUFNLFFBQVEsSUFBSSxLQUFKLENBQVUsT0FBVixDQUFkO0FBQ0EsZUFBSSxJQUFJLEtBQUksQ0FBWixFQUFlLEtBQUksT0FBbkIsRUFBNEIsSUFBNUIsRUFBaUM7QUFDL0Isa0JBQU0sRUFBTixJQUFXLENBQVg7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsY0FBSSxvQkFBb0IsSUFBSSxLQUFKLENBQVUsS0FBSyxpQkFBZixDQUF4QjtBQUNBLGVBQUksSUFBSSxNQUFJLENBQVosRUFBZSxNQUFJLEtBQUssaUJBQXhCLEVBQTJDLEtBQTNDLEVBQWdEO0FBQzlDLDhCQUFrQixHQUFsQixJQUF1QixHQUF2QjtBQUNEOztBQUVELGNBQU0sU0FBUztBQUNiLDBCQUFjLEVBQUUsYUFBRixDQUFnQixrQkFBaEIsQ0FBbUMsWUFEcEM7QUFFYixnQ0FBb0IsQ0FGUDtBQUdiLDRCQUFnQixDQUhIO0FBSWI7QUFDQTtBQUNBLCtCQUFtQixpQkFOTjtBQU9iLHFDQUF5QixDQVBaO0FBUWIsc0JBQVUsQ0FSRzs7QUFVYiw2QkFBaUIsQ0FWSjtBQVdiLHdCQUFZLENBWEM7O0FBYWIsNkJBQWlCLENBQUMsQ0FiTDs7QUFlYjtBQUNBLDRCQUFnQixNQUFNLEtBQU4sQ0FBWSxDQUFaLENBaEJIO0FBaUJiLG1CQUFPLEtBakJNO0FBa0JiO0FBQ0EscUJBQVMsT0FuQkk7QUFvQmIsbUJBQU8sSUFBSSxLQUFKLENBQVUsT0FBVixDQXBCTTtBQXFCYix3QkFBWSxJQUFJLEtBQUosQ0FBVSxPQUFWLENBckJDOztBQXVCYjtBQUNBLDZCQUFpQixDQXhCSjtBQXlCYiw2QkFBaUIsQ0F6Qko7QUEwQmIsMkNBQStCLENBMUJsQjs7QUE0QmI7QUFDQSxpQ0FBcUIsS0E3QlI7O0FBK0JiLHdDQUE0QixFQS9CZixDQStCbUI7QUEvQm5CLFdBQWY7O0FBa0NBLGlCQUFPLGFBQVAsR0FBdUIsS0FBSyxhQUFMLENBQW1CLGFBQW5CLENBQWlDLEtBQWpDLENBQXVDLENBQXZDLENBQXZCO0FBQ0EsaUJBQU8saUJBQVAsR0FBMkIsS0FBSyxhQUFMLENBQW1CLGlCQUFuQixDQUFxQyxLQUFyQyxDQUEyQyxDQUEzQyxDQUEzQjs7QUFFQTtBQUNBLGVBQUksSUFBSSxNQUFJLENBQVosRUFBZSxNQUFJLE9BQW5CLEVBQTRCLEtBQTVCLEVBQWlDO0FBQy9CLGdCQUFNLFNBQVM7QUFDYixrQ0FBb0IsQ0FEUDtBQUViLDhCQUFnQjtBQUZILGFBQWY7QUFJQSxtQkFBTyxJQUFQLEdBQWMsSUFBSSxLQUFKLENBQVUsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixHQUFuQixFQUFzQixVQUF0QixDQUFpQyxTQUEzQyxDQUFkO0FBQ0EsaUJBQUksSUFBSSxLQUFJLENBQVosRUFBZSxLQUFJLE9BQU8sSUFBUCxDQUFZLE1BQS9CLEVBQXVDLElBQXZDLEVBQTRDO0FBQzFDLHFCQUFPLElBQVAsQ0FBWSxFQUFaLElBQWlCLElBQUksT0FBTyxJQUFQLENBQVksTUFBakM7QUFDRDtBQUNELG1CQUFPLGFBQVAsR0FBdUIsT0FBTyxhQUFQLENBQXFCLEtBQXJCLENBQTJCLENBQTNCLENBQXZCO0FBQ0EsbUJBQU8saUJBQVAsR0FBMkIsT0FBTyxpQkFBUCxDQUF5QixLQUF6QixDQUErQixDQUEvQixDQUEzQjs7QUFFQSxtQkFBTywwQkFBUCxDQUFrQyxJQUFsQyxDQUF1QyxNQUF2QztBQUNEOztBQUVELGVBQUssYUFBTCxDQUFtQiwwQkFBbkIsQ0FBOEMsSUFBOUMsQ0FBbUQsTUFBbkQ7QUFDRDtBQUNGO0FBQ0YsSzt3QkFpQ1c7QUFDVixVQUFHLEtBQUssTUFBTCxLQUFnQixTQUFuQixFQUE4QjtBQUM1QixlQUFPLEtBQUssVUFBTCxDQUFnQix5QkFBZSxLQUFLLE1BQXBCLENBQWhCLENBQVA7QUFDRDtBQUNELGFBQU8sU0FBUDtBQUNEOzs7c0JBcENvQixhLEVBQWU7QUFDbEMsV0FBSyxpQkFBTCxHQUF5QixhQUF6QjtBQUNBLFVBQUcsS0FBSyxNQUFMLEtBQWdCLFNBQW5CLEVBQThCO0FBQzlCLFVBQU0sTUFBTSxLQUFLLGFBQUwsQ0FBbUIsdUJBQS9CO0FBQ0EsV0FBSSxJQUFJLElBQUUsQ0FBVixFQUFhLElBQUUsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixNQUFsQyxFQUEwQyxHQUExQyxFQUErQztBQUM3QyxZQUFJLENBQUosRUFBTyxpQkFBUCxHQUEyQixJQUFJLEtBQUosQ0FBVSxLQUFLLGlCQUFmLENBQTNCO0FBQ0EsYUFBSSxJQUFJLElBQUUsQ0FBVixFQUFhLElBQUUsS0FBSyxpQkFBcEIsRUFBdUMsR0FBdkMsRUFBNEM7QUFDMUMsY0FBSSxpQkFBSixDQUFzQixDQUF0QixJQUEyQixJQUFJLEtBQUssaUJBQXBDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7d0JBMEJ1QjtBQUNyQixhQUFPLEtBQUssaUJBQVo7QUFDRDs7O3dCQTFCb0I7QUFDbkIsVUFBRyxLQUFLLGFBQUwsS0FBdUIsU0FBMUIsRUFBcUM7QUFDbkMsWUFBRyxLQUFLLGFBQUwsQ0FBbUIsU0FBbkIsR0FBK0IsQ0FBQyxDQUFuQyxFQUFzQztBQUNwQyxpQkFBTyxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLEtBQUssYUFBTCxDQUFtQixTQUF0QyxFQUFpRCxLQUF4RDtBQUNEO0FBQ0Y7QUFDRCxhQUFPLFNBQVA7QUFDQTtBQUNEOzs7d0JBRWU7QUFDZCxVQUFHLEtBQUssTUFBTCxLQUFnQixTQUFuQixFQUE4QjtBQUM1QixlQUFPLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFBMUI7QUFDRDtBQUNELGFBQU8sQ0FBUDtBQUNEOzs7S0EvUkg7OztrQkFVcUIsVyIsImZpbGUiOiJoaG1tLWRlY29kZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL2ltcG9ydCAqIGFzIGdtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2dtbS11dGlscyc7XG5pbXBvcnQgKiBhcyBoaG1tVXRpbHMgZnJvbSAnLi4vdXRpbHMvaGhtbS11dGlscyc7XG5cbi8qKlxuICogSGllcmFyY2hpY2FsIEhNTSBkZWNvZGVyXG4gKiBsb2FkcyBhIG1vZGVsIHRyYWluZWQgYnkgdGhlIFhNTSBsaWJyYXJ5IGFuZCBwcm9jZXNzZXMgYW4gaW5wdXQgc3RyZWFtIG9mIGZsb2F0IHZlY3RvcnMgaW4gcmVhbC10aW1lXG4gKiBpZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgZm9yIHJlZ3Jlc3Npb24sIG91dHB1dHMgYW4gZXN0aW1hdGlvblxuICogQGNsYXNzXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGhtbURlY29kZXIge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2luZG93U2l6ZSAtIHNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvd1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2luZG93U2l6ZSA9IDEpIHtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvd1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IHdpbmRvd1NpemU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwsIGFzIGdlbmVyYXRlZCBieSBYTU0gZnJvbSBhIHRyYWluaW5nIGRhdGEgc2V0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIEhobW1SZXN1bHRzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsaWtlbGllc3QgLSB0aGUgbGlrZWxpZXN0IG1vZGVsJ3MgbGFiZWxcbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IGxpa2VsaWhvb2RzIC0gdGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIG5vcm1hbGl6ZWQgbGlrZWxpaG9vZHNcbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IHRpbWVQcm9ncmVzc2lvbnMgLSB0aGUgYXJyYXkgb2YgYWxsIG1vZGVscycgbm9ybWFsaXplZCB0aW1lIHByb2dyZXNzaW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5LkFycmF5Lm51bWJlcn0gYWxwaGFzIC0gdGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIHN0YXRlcyBsaWtlbGlob29kcyBhcnJheVxuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dFZhbHVlcyAtIGlmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoIHJlZ3Jlc3Npb24sIHRoZSBlc3RpbWF0ZWQgZmxvYXQgdmVjdG9yIG91dHB1dFxuICAgKi9cblxuICAvKipcbiAgICogQ2FsbGJhY2sgaGFuZGxpbmcgZXN0aW1hdGlvbiByZXN1bHRzXG4gICAqIEBjYWxsYmFjayBSZXN1bHRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIGRlc2NyaXB0aW9uIG9mIGEgcG90ZW50aWFsIGVycm9yXG4gICAqIEBwYXJhbSB7SGhtbVJlc3VsdHN9IHJlcyAtIG9iamVjdCBob2xkaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBkZWNvZGluZyBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FycmF5Lm51bWJlcn0gb2JzZXJ2YXRpb24gLSBhbiBpbnB1dCBmbG9hdCB2ZWN0b3IgdG8gYmUgZXN0aW1hdGVkXG4gICAqIEBwYXJhbSB7UmVzdWx0c0NhbGxiYWNrfSByZXN1bHRzQ2FsbGJhY2sgLSB0aGUgY2FsbGJhY2sgaGFuZGxpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0c1xuICAgKi9cbiAgZmlsdGVyKG9ic2VydmF0aW9uLCByZXN1bHRzQ2FsbGJhY2spIHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIGlmKHRoaXMuX21vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVyciA9ICdubyBtb2RlbCBsb2FkZWQgeWV0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGhtbVV0aWxzLmhobW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMuX21vZGVsLCB0aGlzLl9tb2RlbFJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXN1bHRzIG9iamVjdCBmcm9tIHJlbGV2YW50IG1vZGVsUmVzdWx0cyB2YWx1ZXMgOlxuXG4gICAgICAgIGNvbnN0IGxrbHN0ID0gKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnN0IGxrbGhkcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzLnNsaWNlKDApO1xuICAgICAgICByZXMgPSB7XG4gICAgICAgICAgbGlrZWxpZXN0OiBsa2xzdCxcbiAgICAgICAgICBsaWtlbGlob29kczogbGtsaGRzLFxuICAgICAgICAgIGFscGhhczogbmV3IEFycmF5KHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGgpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYodGhpcy5fbW9kZWwuY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuaGllcmFyY2hpY2FsKSB7XG4gICAgICAgICAgICByZXMuYWxwaGFzW2ldXG4gICAgICAgICAgICAgID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzW2ldLmFscGhhX2hbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcy5hbHBoYXNbaV1cbiAgICAgICAgICAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0uYWxwaGFbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fbW9kZWwuc2hhcmVkX3BhcmFtZXRlcnMuYmltb2RhbCkge1xuICAgICAgICAgIHJlcy5vdXRwdXRWYWx1ZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgICAvLyByZXN1bHRzLm91dHB1dENvdmFyaWFuY2VcbiAgICAgICAgICAvLyAgICAgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gJ3Byb2JsZW0gb2NjdXJlZCBkdXJpbmcgZmlsdGVyaW5nIDogJyArIGU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJlc3VsdHNDYWxsYmFjayhlcnIsIHJlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBvZiB0aGUgZXN0aW1hdGlvblxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgLyoqIEB0b2RvIDogd3JpdGUgYSByZWFsIHJlc2V0IChzZWUgYysrIHZlcnNpb24pICovXG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzLmZvcndhcmRfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09IFNFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09PSAvL1xuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgZ2VuZXJhdGVkIGJ5IFhNTVxuICAgKiBJdCBpcyBtYW5kYXRvcnkgZm9yIHRoZSBjbGFzcyB0byBoYXZlIGEgbW9kZWwgaW4gb3JkZXIgdG8gZG8gaXRzIGpvYlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc2V0IG1vZGVsKG1vZGVsKSB7ICAgICAgXG5cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tb2RlbFJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyB0ZXN0IGlmIG1vZGVsIGlzIHZhbGlkIGhlcmUgKFRPRE8gOiB3cml0ZSBhIGJldHRlciB0ZXN0KVxuICAgIGlmKG1vZGVsLm1vZGVscyAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgIC8vY29uc29sZS5sb2cobW9kZWwpO1xuXG4gICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgICAgY29uc3QgbSA9IHRoaXMuX21vZGVsO1xuICAgICAgY29uc3Qgbm1vZGVscyA9IG0ubW9kZWxzLmxlbmd0aDtcblxuICAgICAgLy8gbm90IHVzZWQgYW55bW9yZSAocmV0dXJucyBhIG1vcmUgY29tcGxleCBqcyBvYmplY3QpXG4gICAgICAvLyBjb25zdCBuc3RhdGVzR2xvYmFsID0gbS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5zdGF0ZXM7XG4gICAgICAvLyB0aGlzLnBhcmFtcy5mcmFtZVNpemUgPSBuc3RhdGVzR2xvYmFsO1xuXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMgPSB7XG4gICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGxpa2VsaWVzdDogLTEsXG4gICAgICAgIGZyb250aWVyX3YxOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGZyb250aWVyX3YyOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGZvcndhcmRfaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICBzaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0czogW11cbiAgICAgIH07XG5cbiAgICAgIC8vIG1vdmUgb3V0cHV0X3ZhbHVlcyAvIG91dHB1dF9jb3ZhcmlhbmNlIGhlcmUgZm9yIHJlZ3Jlc3Npb25cbiAgICAgIC8vIGFuZCBkdXBlICguc2xpY2UoMCkpIHRoZW0gaW4gc3ViLW1vZGVsUmVzdWx0c1xuICAgICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGRpbU91dCA9IHBhcmFtcy5kaW1lbnNpb24gLSBwYXJhbXMuZGltZW5zaW9uX2lucHV0O1xuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMgPSBuZXcgQXJyYXkoZGltT3V0KTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlc1tpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dENvdmFyU2l6ZTtcbiAgICAgIGlmKG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuY292YXJpYW5jZV9tb2RlID09IDApIHsgLy8gZnVsbFxuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQgKiBkaW1PdXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZGlhZ29uYWxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlID0gbmV3IEFycmF5KG91dENvdmFyU2l6ZSk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlW2ldID0gMC4wO1xuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbm1vZGVsczsgaSsrKSB7XG5cbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzW2ldID0gMDtcblxuICAgICAgICBjb25zdCBuc3RhdGVzID0gbS5tb2RlbHNbaV0ucGFyYW1ldGVycy5zdGF0ZXM7XG5cbiAgICAgICAgY29uc3QgYWxwaGFfaCA9IG5ldyBBcnJheSgzKTtcbiAgICAgICAgZm9yKGxldCBqPTA7IGo8MzsgaisrKSB7XG4gICAgICAgICAgYWxwaGFfaFtqXSA9IG5ldyBBcnJheShuc3RhdGVzKTtcbiAgICAgICAgICBmb3IobGV0IGs9MDsgazxuc3RhdGVzOyBrKyspIHtcbiAgICAgICAgICAgIGFscGhhX2hbal1ba10gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYWxwaGEgPSBuZXcgQXJyYXkobnN0YXRlcyk7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCBuc3RhdGVzOyBqKyspIHtcbiAgICAgICAgICBhbHBoYVtqXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdCB3aW5TaXplID0gbS5zaGFyZWRfcGFyYW1ldGVycy5saWtlbGlob29kX3dpbmRvd1xuICAgICAgICAvLyBsZXQgbGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkod2luU2l6ZSk7XG4gICAgICAgIGxldCBsaWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG1tUmVzID0ge1xuICAgICAgICAgIGhpZXJhcmNoaWNhbDogbS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5oaWVyYXJjaGljYWwsXG4gICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwLFxuICAgICAgICAgIC8vIGZvciBjaXJjdWxhciBidWZmZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyAoc2VlIGhtbVVwZGF0ZVJlc3VsdHMpIDpcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcjogbGlrZWxpaG9vZF9idWZmZXIsXG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXJfaW5kZXg6IDAsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG5cbiAgICAgICAgICBleGl0X2xpa2VsaWhvb2Q6IDAsXG4gICAgICAgICAgZXhpdF9yYXRpbzogMCxcblxuICAgICAgICAgIGxpa2VsaWVzdF9zdGF0ZTogLTEsXG5cbiAgICAgICAgICAvLyBmb3Igbm9uLWhpZXJhcmNoaWNhbCA6XG4gICAgICAgICAgcHJldmlvdXNfYWxwaGE6IGFscGhhLnNsaWNlKDApLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgICAvLyBmb3IgaGllcmFyY2hpY2FsIDogICAgICAgXG4gICAgICAgICAgYWxwaGFfaDogYWxwaGFfaCxcbiAgICAgICAgICBwcmlvcjogbmV3IEFycmF5KG5zdGF0ZXMpLFxuICAgICAgICAgIHRyYW5zaXRpb246IG5ldyBBcnJheShuc3RhdGVzKSxcblxuICAgICAgICAgIC8vIHVzZWQgaW4gaG1tVXBkYXRlQWxwaGFXaW5kb3dcbiAgICAgICAgICB3aW5kb3dfbWluaW5kZXg6IDAsXG4gICAgICAgICAgd2luZG93X21heGluZGV4OiAwLFxuICAgICAgICAgIHdpbmRvd19ub3JtYWxpemF0aW9uX2NvbnN0YW50OiAwLFxuXG4gICAgICAgICAgLy8gZm9yIG5vbi1oaWVyYXJjaGljYWwgbW9kZVxuICAgICAgICAgIGZvcndhcmRfaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgIFxuICAgICAgICAgIHNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzOiBbXSAgLy8gc3RhdGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaG1tUmVzLm91dHB1dF92YWx1ZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgaG1tUmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIGFkZCBITU0gc3RhdGVzIChHTU1zKVxuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgbnN0YXRlczsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZ21tUmVzID0ge1xuICAgICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgICAgbG9nX2xpa2VsaWhvb2Q6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdtbVJlcy5iZXRhID0gbmV3IEFycmF5KHRoaXMuX21vZGVsLm1vZGVsc1tpXS5wYXJhbWV0ZXJzLmdhdXNzaWFucyk7XG4gICAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IGdtbVJlcy5iZXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBnbW1SZXMuYmV0YVtrXSA9IDEgLyBnbW1SZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdtbVJlcy5vdXRwdXRfdmFsdWVzID0gaG1tUmVzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgZ21tUmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gaG1tUmVzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgICAgaG1tUmVzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2goZ21tUmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0cy5wdXNoKGhtbVJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAgIGlmKHRoaXMuX21vZGVsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCByZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NNb2RlbFJlc3VsdHM7XG4gICAgZm9yKGxldCBpPTA7IGk8dGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICBmb3IobGV0IGo9MDsgajx0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gR0VUVEVSUyA9PT09PT09PT09PT09PT09PT09PT09IC8vXG5cbiAgZ2V0IGxpa2VsaWVzdExhYmVsKCkge1xuICAgIGlmKHRoaXMuX21vZGVsUmVzdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZih0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVsc1t0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0XS5sYWJlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICd1bmtub3duJztcbiAgICAvL3JldHVybignbm8gZXN0aW1hdGlvbiBhdmFpbGFibGUnKTtcbiAgfVxuXG4gIGdldCBuYkNsYXNzZXMoKSB7XG4gICAgaWYodGhpcy5fbW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0IG1vZGVsKCkge1xuICAgIGlmKHRoaXMuX21vZGVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBKU09OLmZyb21TdHJpbmcoSlNPTi5zdHJpbmdpZnkodGhpcy5fbW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCBsaWtlbGlob29kV2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICB9XG59Il19