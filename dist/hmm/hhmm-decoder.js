'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vector in real-time
 * if the model was trained for regression, outputs an estimation
 */

var HhmmDecoder = function () {

  /**
   * @param {String} windowSize - size of the likelihood smoothing window
   */
  function HhmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this.model = undefined;

    /**
     * The model results, containing intermediate results that will be returned
     * @type {Object}
     */
    this.modelResults = undefined;

    /**
     * Size of the likelihood smoothing window
     * @type {Number}
     */
    this.likelihoodWindow = windowSize;
  }

  /**
   * The decoding function
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      if (this.model === undefined) {
        console.log("no model loaded");
        return;
      }

      var err = null;
      var results = null;

      try {
        hhmmUtils.hhmmFilter(observation, this.model, this.modelResults);

        // create results object from relevant modelResults values :

        var lklst = this.modelResults.likeliest > -1 ? this.model.models[this.modelResults.likeliest].label : 'unknown';
        var lklhds = this.modelResults.smoothed_normalized_likelihoods.slice(0);
        results = {
          likeliest: lklst,
          likelihoods: lklhds,
          alphas: new Array(this.model.models.length)
        };

        for (var i = 0; i < this.model.models.length; i++) {
          if (this.model.configuration.default_parameters.hierarchical) {
            result.alphas[i] = this.modelResults.singleClassHmmModelResults[i].alpha_h[0];
          } else {
            result.alphas[i] = this.modelResults.singleClassHmmModelResults[i].alpha[0];
          }
        }

        if (this.model.shared_parameters.bimodal) {
          results.output_values = this.modelResults.output_values.slice(0);
          // results.output_covariance
          //     = this.modelResults.output_covariance.slice(0);
        }
      } catch (e) {
        err = 'problem occured during filtering : ' + e;
      }
      resultsCallback(err, results);
    }

    /**
     *
     */

  }, {
    key: 'reset',
    value: function reset() {
      /** @todo : write a real reset (see c++ version) */
      this.modelResults.forward_initialized = false;
    }

    // ==================== SETTERS ====================== //

    /**
     * Loads the model and initializes the modelResults object
     */

  }, {
    key: 'model',
    set: function set(model) {

      this.model = undefined;
      this.modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {

        //console.log(model);

        this.model = model;
        var m = this.model;
        var nmodels = m.models.length;

        // not used anymore (returns a more complex js object)
        // const nstatesGlobal = m.configuration.default_parameters.states;
        // this.params.frameSize = nstatesGlobal;

        this.modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        // move output_values / output_covariance here for regression
        // and dupe (.slice(0)) them in sub-modelResults
        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this.modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this.modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          // full
          outCovarSize = dimOut * dimOut;
        } else {
          // diagonal
          outCovarSize = dimOut;
        }
        this.modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this.modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this.modelResults.instant_likelihoods[_i2] = 0;
          this.modelResults.smoothed_log_likelihoods[_i2] = 0;
          this.modelResults.smoothed_likelihoods[_i2] = 0;
          this.modelResults.instant_normalized_likelihoods[_i2] = 0;
          this.modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var nstates = m.models[_i2].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          // const winSize = m.shared_parameters.likelihood_window
          // let likelihood_buffer = new Array(winSize);
          var likelihood_buffer = new Array(this.likelihoodWindow);
          for (var _j2 = 0; _j2 < this.likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            // never used ? -> check xmm cpp
            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            prior: new Array(nstates),
            transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // states
          };

          hmmRes.output_values = this.modelResults.output_values.slice(0);
          hmmRes.output_covariance = this.modelResults.output_covariance.slice(0);

          // ADD INDIVIDUAL STATES (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this.model.models[_i2].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this.modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }

      // ========== LFO specific
      // this.initialize({ frameSize: this.model.models.length });
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this.likelihoodWindow = newWindowSize;
      if (this.model === undefined) return;
      var res = this.modelResults.singleClassModelResults;
      for (var i = 0; i < this.model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this.likelihoodWindow);
        for (var j = 0; j < this.likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this.likelihoodWindow;
        }
      }
    }

    // ==================== GETTERS ====================== //

  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this.modelResults !== undefined) {
        if (this.modelResults.likeliest > -1) {
          return this.model.models[this.modelResults.likeliest].label;
        }
      }
      return 'unknown';
      //return('no estimation available');
    }
  }]);
  return HhmmDecoder;
}(); //import * as gmmUtils from '../utils/gmm-utils';


exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,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QUFrQixLQUFLLFlBQUwsQ0FBa0IsU0FBcEMsRUFBK0MsS0FBdEQ7QUFDRDtBQUNGO0FBQ0QsYUFBTyxTQUFQO0FBQ0E7QUFDRDs7O0tBdFFIOzs7a0JBU3FCLFciLCJmaWxlIjoiaGhtbS1kZWNvZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9pbXBvcnQgKiBhcyBnbW1VdGlscyBmcm9tICcuLi91dGlscy9nbW0tdXRpbHMnO1xuaW1wb3J0ICogYXMgaGhtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2hobW0tdXRpbHMnO1xuXG4vKipcbiAqIEhpZXJhcmNoaWNhbCBITU0gZGVjb2RlclxuICogbG9hZHMgYSBtb2RlbCB0cmFpbmVkIGJ5IHRoZSBYTU0gbGlicmFyeSBhbmQgcHJvY2Vzc2VzIGFuIGlucHV0IHN0cmVhbSBvZiBmbG9hdCB2ZWN0b3IgaW4gcmVhbC10aW1lXG4gKiBpZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgZm9yIHJlZ3Jlc3Npb24sIG91dHB1dHMgYW4gZXN0aW1hdGlvblxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhobW1EZWNvZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHdpbmRvd1NpemUgLSBzaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3dcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwsIGFzIGdlbmVyYXRlZCBieSBYTU0gZnJvbSBhIHRyYWluaW5nIGRhdGEgc2V0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVsID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsIHJlc3VsdHMsIGNvbnRhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMgdGhhdCB3aWxsIGJlIHJldHVybmVkXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvd1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5saWtlbGlob29kV2luZG93ID0gd2luZG93U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVjb2RpbmcgZnVuY3Rpb25cbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrKSB7XG4gICAgaWYodGhpcy5tb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm5vIG1vZGVsIGxvYWRlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzdWx0cyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgaGhtbVV0aWxzLmhobW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMubW9kZWwsIHRoaXMubW9kZWxSZXN1bHRzKTtcblxuICAgICAgLy8gY3JlYXRlIHJlc3VsdHMgb2JqZWN0IGZyb20gcmVsZXZhbnQgbW9kZWxSZXN1bHRzIHZhbHVlcyA6XG5cbiAgICAgIGNvbnN0IGxrbHN0ID0gKHRoaXMubW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKVxuICAgICAgICAgICAgICAgICAgPyB0aGlzLm1vZGVsLm1vZGVsc1t0aGlzLm1vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsXG4gICAgICAgICAgICAgICAgICA6ICd1bmtub3duJztcbiAgICAgIGNvbnN0IGxrbGhkcyA9IHRoaXMubW9kZWxSZXN1bHRzLnNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMuc2xpY2UoMCk7XG4gICAgICByZXN1bHRzID0ge1xuICAgICAgICBsaWtlbGllc3Q6IGxrbHN0LFxuICAgICAgICBsaWtlbGlob29kczogbGtsaGRzLFxuICAgICAgICBhbHBoYXM6IG5ldyBBcnJheSh0aGlzLm1vZGVsLm1vZGVscy5sZW5ndGgpXG4gICAgICB9XG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZih0aGlzLm1vZGVsLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmhpZXJhcmNoaWNhbCkge1xuICAgICAgICAgIHJlc3VsdC5hbHBoYXNbaV1cbiAgICAgICAgICAgID0gdGhpcy5tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0uYWxwaGFfaFswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuYWxwaGFzW2ldXG4gICAgICAgICAgICA9IHRoaXMubW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzW2ldLmFscGhhWzBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMubW9kZWwuc2hhcmVkX3BhcmFtZXRlcnMuYmltb2RhbCkge1xuICAgICAgICByZXN1bHRzLm91dHB1dF92YWx1ZXMgPSB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAvLyByZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlXG4gICAgICAgIC8vICAgICA9IHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9ICdwcm9ibGVtIG9jY3VyZWQgZHVyaW5nIGZpbHRlcmluZyA6ICcgKyBlO1xuICAgIH1cbiAgICByZXN1bHRzQ2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgLyoqIEB0b2RvIDogd3JpdGUgYSByZWFsIHJlc2V0IChzZWUgYysrIHZlcnNpb24pICovXG4gICAgdGhpcy5tb2RlbFJlc3VsdHMuZm9yd2FyZF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT0gU0VUVEVSUyA9PT09PT09PT09PT09PT09PT09PT09IC8vXG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBtb2RlbCBhbmQgaW5pdGlhbGl6ZXMgdGhlIG1vZGVsUmVzdWx0cyBvYmplY3RcbiAgICovXG4gIHNldCBtb2RlbChtb2RlbCkgeyAgICAgIFxuXG4gICAgdGhpcy5tb2RlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHRlc3QgaWYgbW9kZWwgaXMgdmFsaWQgaGVyZSAoVE9ETyA6IHdyaXRlIGEgYmV0dGVyIHRlc3QpXG4gICAgaWYobW9kZWwubW9kZWxzICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgLy9jb25zb2xlLmxvZyhtb2RlbCk7XG5cbiAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLm1vZGVsO1xuICAgICAgY29uc3Qgbm1vZGVscyA9IG0ubW9kZWxzLmxlbmd0aDtcblxuICAgICAgLy8gbm90IHVzZWQgYW55bW9yZSAocmV0dXJucyBhIG1vcmUgY29tcGxleCBqcyBvYmplY3QpXG4gICAgICAvLyBjb25zdCBuc3RhdGVzR2xvYmFsID0gbS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5zdGF0ZXM7XG4gICAgICAvLyB0aGlzLnBhcmFtcy5mcmFtZVNpemUgPSBuc3RhdGVzR2xvYmFsO1xuXG4gICAgICB0aGlzLm1vZGVsUmVzdWx0cyA9IHtcbiAgICAgICAgaW5zdGFudF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9sb2dfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgaW5zdGFudF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgbGlrZWxpZXN0OiAtMSxcbiAgICAgICAgZnJvbnRpZXJfdjE6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgZnJvbnRpZXJfdjI6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgZm9yd2FyZF9pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgIHNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gbW92ZSBvdXRwdXRfdmFsdWVzIC8gb3V0cHV0X2NvdmFyaWFuY2UgaGVyZSBmb3IgcmVncmVzc2lvblxuICAgICAgLy8gYW5kIGR1cGUgKC5zbGljZSgwKSkgdGhlbSBpbiBzdWItbW9kZWxSZXN1bHRzXG4gICAgICBjb25zdCBwYXJhbXMgPSBtLnNoYXJlZF9wYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgZGltT3V0ID0gcGFyYW1zLmRpbWVuc2lvbiAtIHBhcmFtcy5kaW1lbnNpb25faW5wdXQ7XG4gICAgICB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzID0gbmV3IEFycmF5KGRpbU91dCk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlc1tpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dENvdmFyU2l6ZTtcbiAgICAgIGlmKG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuY292YXJpYW5jZV9tb2RlID09IDApIHsgLy8gZnVsbFxuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQgKiBkaW1PdXQ7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZGlhZ29uYWxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZVtpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5tb2RlbHM7IGkrKykge1xuXG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLmluc3RhbnRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5zbW9vdGhlZF9sb2dfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLmluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLnNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuXG4gICAgICAgIGNvbnN0IG5zdGF0ZXMgPSBtLm1vZGVsc1tpXS5wYXJhbWV0ZXJzLnN0YXRlcztcblxuICAgICAgICBjb25zdCBhbHBoYV9oID0gbmV3IEFycmF5KDMpO1xuICAgICAgICBmb3IobGV0IGo9MDsgajwzOyBqKyspIHtcbiAgICAgICAgICBhbHBoYV9oW2pdID0gbmV3IEFycmF5KG5zdGF0ZXMpO1xuICAgICAgICAgIGZvcihsZXQgaz0wOyBrPG5zdGF0ZXM7IGsrKykge1xuICAgICAgICAgICAgYWxwaGFfaFtqXVtrXSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBhbHBoYSA9IG5ldyBBcnJheShuc3RhdGVzKTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG5zdGF0ZXM7IGorKykge1xuICAgICAgICAgIGFscGhhW2pdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnN0IHdpblNpemUgPSBtLnNoYXJlZF9wYXJhbWV0ZXJzLmxpa2VsaWhvb2Rfd2luZG93XG4gICAgICAgIC8vIGxldCBsaWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh3aW5TaXplKTtcbiAgICAgICAgbGV0IGxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMubGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmxpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG1tUmVzID0ge1xuICAgICAgICAgIGhpZXJhcmNoaWNhbDogbS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5oaWVyYXJjaGljYWwsXG4gICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwLFxuICAgICAgICAgIC8vIGZvciBjaXJjdWxhciBidWZmZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyAoc2VlIGhtbVVwZGF0ZVJlc3VsdHMpIDpcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcjogbGlrZWxpaG9vZF9idWZmZXIsXG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXJfaW5kZXg6IDAsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG5cbiAgICAgICAgICAvLyBuZXZlciB1c2VkID8gLT4gY2hlY2sgeG1tIGNwcFxuICAgICAgICAgIGV4aXRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBleGl0X3JhdGlvOiAwLFxuXG4gICAgICAgICAgbGlrZWxpZXN0X3N0YXRlOiAtMSxcblxuICAgICAgICAgIC8vIGZvciBub24taGllcmFyY2hpY2FsIDpcbiAgICAgICAgICBwcmV2aW91c19hbHBoYTogYWxwaGEuc2xpY2UoMCksXG4gICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICAgIC8vIGZvciBoaWVyYXJjaGljYWwgOiAgICAgICBcbiAgICAgICAgICBhbHBoYV9oOiBhbHBoYV9oLFxuICAgICAgICAgIHByaW9yOiBuZXcgQXJyYXkobnN0YXRlcyksXG4gICAgICAgICAgdHJhbnNpdGlvbjogbmV3IEFycmF5KG5zdGF0ZXMpLFxuXG4gICAgICAgICAgLy8gdXNlZCBpbiBobW1VcGRhdGVBbHBoYVdpbmRvd1xuICAgICAgICAgIHdpbmRvd19taW5pbmRleDogMCxcbiAgICAgICAgICB3aW5kb3dfbWF4aW5kZXg6IDAsXG4gICAgICAgICAgd2luZG93X25vcm1hbGl6YXRpb25fY29uc3RhbnQ6IDAsXG5cbiAgICAgICAgICAvLyBmb3Igbm9uLWhpZXJhcmNoaWNhbCBtb2RlXG4gICAgICAgICAgZm9yd2FyZF9pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgXG4gICAgICAgICAgc2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHM6IFtdICAvLyBzdGF0ZXNcbiAgICAgICAgfTtcblxuICAgICAgICBobW1SZXMub3V0cHV0X3ZhbHVlcyA9IHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIGhtbVJlcy5vdXRwdXRfY292YXJpYW5jZSA9IHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIEFERCBJTkRJVklEVUFMIFNUQVRFUyAoR01NcylcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IG5zdGF0ZXM7IGorKykge1xuICAgICAgICAgIGNvbnN0IGdtbVJlcyA9IHtcbiAgICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbW1SZXMuYmV0YSA9IG5ldyBBcnJheSh0aGlzLm1vZGVsLm1vZGVsc1tpXS5wYXJhbWV0ZXJzLmdhdXNzaWFucyk7XG4gICAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IGdtbVJlcy5iZXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBnbW1SZXMuYmV0YVtrXSA9IDEgLyBnbW1SZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdtbVJlcy5vdXRwdXRfdmFsdWVzID0gaG1tUmVzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgZ21tUmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gaG1tUmVzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgICAgaG1tUmVzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2goZ21tUmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzLnB1c2goaG1tUmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09IExGTyBzcGVjaWZpY1xuICAgIC8vIHRoaXMuaW5pdGlhbGl6ZSh7IGZyYW1lU2l6ZTogdGhpcy5tb2RlbC5tb2RlbHMubGVuZ3RoIH0pO1xuICB9XG5cbiAgc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMubGlrZWxpaG9vZFdpbmRvdyA9IG5ld1dpbmRvd1NpemU7XG4gICAgaWYodGhpcy5tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgY29uc3QgcmVzID0gdGhpcy5tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NNb2RlbFJlc3VsdHM7XG4gICAgZm9yKGxldCBpPTA7IGk8dGhpcy5tb2RlbC5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXS5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLmxpa2VsaWhvb2RXaW5kb3cpO1xuICAgICAgZm9yKGxldCBqPTA7IGo8dGhpcy5saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMubGlrZWxpaG9vZFdpbmRvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PSBHRVRURVJTID09PT09PT09PT09PT09PT09PT09PT0gLy9cblxuICBnZXQgbGlrZWxpZXN0TGFiZWwoKSB7XG4gICAgaWYodGhpcy5tb2RlbFJlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYodGhpcy5tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubW9kZWxzW3RoaXMubW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG4gICAgLy9yZXR1cm4oJ25vIGVzdGltYXRpb24gYXZhaWxhYmxlJyk7XG4gIH1cbn0iXX0=