'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _gmmUtils = require('../utils/gmm-utils');

var gmmUtils = _interopRequireWildcard(_gmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GMM decoder <br />
 * Loads a model trained by the XMM library and processes an input stream of float vectors in real-time.
 * If the model was trained for regression, outputs an estimation of the associated process.
 * @class
 */

var GmmDecoder = function () {

  /**
   * @param {Number} [windowSize=1] - Size of the likelihood smoothing window.
   */
  function GmmDecoder() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, GmmDecoder);


    /**
     * The model, as generated by XMM from a training data set.
     * @type {Object}
     * @private
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter.
     * @type {Object}
     * @private
     */
    this._modelResults = undefined;

    /**
     * Size of the likelihood smoothing window.
     * @type {Number}
     * @private
     */
    this._likelihoodWindow = windowSize;
  }

  /**
   * Callback handling estimation results.
   * @callback GmmResultsCallback
   * @param {String} err - Description of a potential error.
   * @param {GmmResults} res - Object holding the estimation results.
   */

  /**
   * Results of the filtering process.
   * @typedef GmmResults
   * @type {Object}
   * @property {String} likeliest - The likeliest model's label.
   * @property {Number} likeliestIndex - The likeliest model's index
   * @property {Array.number} likelihoods - The array of all models' smoothed normalized likelihoods.
   * @property {?Array.number} outputValues - If the model was trained with regression, the estimated float vector output.
   * @property {?Array.number} outputCovariance - If the model was trained with regression, the output covariance matrix.
   */

  /**
   * The decoding function.
   * @param {Array} observation - An input float vector to be estimated.
   * @param {GmmResultsCallback} [resultsCallback=null] - The callback handling the estimation results.
   * @returns {GmmResults} results - The estimation results.
   */


  (0, _createClass3.default)(GmmDecoder, [{
    key: 'filter',
    value: function filter(observation) {
      var resultsCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var err = null;
      var res = null;

      if (!this._model) {
        console.log("no model loaded");
        return;
      } else {
        try {
          gmmUtils.gmmFilter(observation, this._model, this._modelResults);

          var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: likeliest,
            likeliestIndex: this._modelResults.likeliest,
            likelihoods: likelihoods
          };

          // add regression results to global results if bimodal :
          if (this._model.shared_parameters.bimodal) {
            res['outputValues'] = this._modelResults.output_values.slice(0);
            res['outputCovariance'] = this.modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      if (resultsCallback) {
        resultsCallback(err, res);
      }
      return res;
    }

    //=========================== GETTERS / SETTERS ============================//

    /**
     * Likelihood smoothing window size.
     * @type {Number}
     */

  }, {
    key: '_updateLikelihoodWindow',


    /** @private */
    value: function _updateLikelihoodWindow() {
      if (this._model === undefined) return;

      var res = this._modelResults.singleClassGmmModelResults;

      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);

        for (var j = 0; j < this._likelihoodWindow; j++) {
          res[i].likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    /**
     * The model generated by XMM.
     * It is mandatory for the class to have a model in order to do its job.
     * @type {Object}
     */

  }, {
    key: '_setModel',


    /** @private */
    value: function _setModel(model) {
      this._model = undefined;
      this._modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          singleClassGmmModelResults: []
        };

        // the following variables are used for regression :
        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);

        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        //------------------------------------------------------------------- full
        if (m.configuration.default_parameters.covariance_mode == 0) {
          outCovarSize = dimOut * dimOut;
          //--------------------------------------------------------------- diagonal
        } else {
          outCovarSize = dimOut;
        }

        this._modelResults.output_covariance = new Array(outCovarSize);

        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var res = {
            instant_likelihood: 0,
            log_likelihood: 0
          };

          res.likelihood_buffer = new Array(this._likelihoodWindow);

          for (var j = 0; j < this._likelihoodWindow; j++) {
            res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
          }

          res.likelihood_buffer_index = 0;

          // the following variables are used for regression :
          res.beta = new Array(m.models[_i2].components.length);

          for (var _j = 0; _j < res.beta.length; _j++) {
            res.beta[_j] = 1 / res.beta.length;
          }

          res.output_values = this._modelResults.output_values.slice(0);
          res.output_covariance = this._modelResults.output_covariance.slice(0);

          // now add this singleModelResults object
          // to the global modelResults object :
          this._modelResults.singleClassGmmModelResults.push(res);
        }
      }
    }

    /**
     * Currently estimated likeliest label.
     * @readonly
     * @type {String}
     */

  }, {
    key: 'likelihoodWindow',
    get: function get() {
      return this._likelihoodWindow;
    },
    set: function set(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      this._updateLikelihoodWindow();
    }
  }, {
    key: 'model',
    get: function get() {
      if (this._model !== undefined) {
        return JSON.parse((0, _stringify2.default)(this._model));
      }
      return undefined;
    },
    set: function set(model) {
      this._setModel(model);
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this._modelResults !== undefined) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }

    /**
     * Number of classes contained in the model.
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'nbClasses',
    get: function get() {
      if (this._model !== undefined) {
        return this._model.models.length;
      }
      return 0;
    }

    /**
     * Size of the regression vector if model is bimodal.
     * @readonly
     * @type {Number}
     */

  }, {
    key: 'regressionSize',
    get: function get() {
      if (this._model !== undefined) {
        return this._model.shared_parameters.dimension_input;
      }
      return 0;
    }
  }]);
  return GmmDecoder;
}();

;

exports.default = GmmDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdtbS1kZWNvZGVyLmpzIl0sIm5hbWVzIjpbImdtbVV0aWxzIiwiR21tRGVjb2RlciIsIndpbmRvd1NpemUiLCJfbW9kZWwiLCJ1bmRlZmluZWQiLCJfbW9kZWxSZXN1bHRzIiwiX2xpa2VsaWhvb2RXaW5kb3ciLCJvYnNlcnZhdGlvbiIsInJlc3VsdHNDYWxsYmFjayIsImVyciIsInJlcyIsImNvbnNvbGUiLCJsb2ciLCJnbW1GaWx0ZXIiLCJsaWtlbGllc3QiLCJtb2RlbHMiLCJsYWJlbCIsImxpa2VsaWhvb2RzIiwic21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcyIsInNsaWNlIiwibGlrZWxpZXN0SW5kZXgiLCJzaGFyZWRfcGFyYW1ldGVycyIsImJpbW9kYWwiLCJvdXRwdXRfdmFsdWVzIiwibW9kZWxSZXN1bHRzIiwib3V0cHV0X2NvdmFyaWFuY2UiLCJlIiwic2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHMiLCJpIiwibGVuZ3RoIiwibGlrZWxpaG9vZF9idWZmZXIiLCJBcnJheSIsImoiLCJtb2RlbCIsIm0iLCJubW9kZWxzIiwiaW5zdGFudF9saWtlbGlob29kcyIsInNtb290aGVkX2xvZ19saWtlbGlob29kcyIsInNtb290aGVkX2xpa2VsaWhvb2RzIiwiaW5zdGFudF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzIiwicGFyYW1zIiwiZGltT3V0IiwiZGltZW5zaW9uIiwiZGltZW5zaW9uX2lucHV0Iiwib3V0Q292YXJTaXplIiwiY29uZmlndXJhdGlvbiIsImRlZmF1bHRfcGFyYW1ldGVycyIsImNvdmFyaWFuY2VfbW9kZSIsImluc3RhbnRfbGlrZWxpaG9vZCIsImxvZ19saWtlbGlob29kIiwibGlrZWxpaG9vZF9idWZmZXJfaW5kZXgiLCJiZXRhIiwiY29tcG9uZW50cyIsInB1c2giLCJuZXdXaW5kb3dTaXplIiwiX3VwZGF0ZUxpa2VsaWhvb2RXaW5kb3ciLCJKU09OIiwicGFyc2UiLCJfc2V0TW9kZWwiXSwibWFwcGluZ3MiOiI7Ozs7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QUFLYixNQUFMLEtBQWdCQyxTQUFwQixFQUErQjtBQUM3QixlQUFPLEtBQUtELE1BQUwsQ0FBWVksTUFBWixDQUFtQmMsTUFBMUI7QUFDRDtBQUNELGFBQU8sQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozt3QkFLcUI7QUFDbkIsVUFBSSxLQUFLMUIsTUFBTCxLQUFnQkMsU0FBcEIsRUFBK0I7QUFDN0IsZUFBTyxLQUFLRCxNQUFMLENBQVlrQixpQkFBWixDQUE4QnNCLGVBQXJDO0FBQ0Q7QUFDRCxhQUFPLENBQVA7QUFDRDs7Ozs7QUFDRjs7a0JBRWMxQyxVIiwiZmlsZSI6ImdtbS1kZWNvZGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZ21tVXRpbHMgZnJvbSAnLi4vdXRpbHMvZ21tLXV0aWxzJztcblxuLyoqXG4gKiBHTU0gZGVjb2RlciA8YnIgLz5cbiAqIExvYWRzIGEgbW9kZWwgdHJhaW5lZCBieSB0aGUgWE1NIGxpYnJhcnkgYW5kIHByb2Nlc3NlcyBhbiBpbnB1dCBzdHJlYW0gb2YgZmxvYXQgdmVjdG9ycyBpbiByZWFsLXRpbWUuXG4gKiBJZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgZm9yIHJlZ3Jlc3Npb24sIG91dHB1dHMgYW4gZXN0aW1hdGlvbiBvZiB0aGUgYXNzb2NpYXRlZCBwcm9jZXNzLlxuICogQGNsYXNzXG4gKi9cblxuY2xhc3MgR21tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZT0xXSAtIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwsIGFzIGdlbmVyYXRlZCBieSBYTU0gZnJvbSBhIHRyYWluaW5nIGRhdGEgc2V0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gd2luZG93U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEBjYWxsYmFjayBHbW1SZXN1bHRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVyciAtIERlc2NyaXB0aW9uIG9mIGEgcG90ZW50aWFsIGVycm9yLlxuICAgKiBAcGFyYW0ge0dtbVJlc3VsdHN9IHJlcyAtIE9iamVjdCBob2xkaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXN1bHRzIG9mIHRoZSBmaWx0ZXJpbmcgcHJvY2Vzcy5cbiAgICogQHR5cGVkZWYgR21tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbGlrZWxpZXN0IC0gVGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbGlrZWxpZXN0SW5kZXggLSBUaGUgbGlrZWxpZXN0IG1vZGVsJ3MgaW5kZXhcbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IGxpa2VsaWhvb2RzIC0gVGhlIGFycmF5IG9mIGFsbCBtb2RlbHMnIHNtb290aGVkIG5vcm1hbGl6ZWQgbGlrZWxpaG9vZHMuXG4gICAqIEBwcm9wZXJ0eSB7P0FycmF5Lm51bWJlcn0gb3V0cHV0VmFsdWVzIC0gSWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIGVzdGltYXRlZCBmbG9hdCB2ZWN0b3Igb3V0cHV0LlxuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dENvdmFyaWFuY2UgLSBJZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgd2l0aCByZWdyZXNzaW9uLCB0aGUgb3V0cHV0IGNvdmFyaWFuY2UgbWF0cml4LlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGRlY29kaW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSBvYnNlcnZhdGlvbiAtIEFuIGlucHV0IGZsb2F0IHZlY3RvciB0byBiZSBlc3RpbWF0ZWQuXG4gICAqIEBwYXJhbSB7R21tUmVzdWx0c0NhbGxiYWNrfSBbcmVzdWx0c0NhbGxiYWNrPW51bGxdIC0gVGhlIGNhbGxiYWNrIGhhbmRsaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEByZXR1cm5zIHtHbW1SZXN1bHRzfSByZXN1bHRzIC0gVGhlIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrID0gbnVsbCkge1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCByZXMgPSBudWxsO1xuXG4gICAgaWYoIXRoaXMuX21vZGVsKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm5vIG1vZGVsIGxvYWRlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ21tVXRpbHMuZ21tRmlsdGVyKG9ic2VydmF0aW9uLCB0aGlzLl9tb2RlbCwgdGhpcy5fbW9kZWxSZXN1bHRzKTsgICAgICAgICBcblxuICAgICAgICBjb25zdCBsaWtlbGllc3QgPSAodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3Vua25vd24nO1xuICAgICAgICBjb25zdCBsaWtlbGlob29kcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzLnNsaWNlKDApO1xuICAgICAgICByZXMgPSB7XG4gICAgICAgICAgbGlrZWxpZXN0OiBsaWtlbGllc3QsXG4gICAgICAgICAgbGlrZWxpZXN0SW5kZXg6IHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QsXG4gICAgICAgICAgbGlrZWxpaG9vZHM6IGxpa2VsaWhvb2RzXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVncmVzc2lvbiByZXN1bHRzIHRvIGdsb2JhbCByZXN1bHRzIGlmIGJpbW9kYWwgOlxuICAgICAgICBpZih0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgICAgcmVzWydvdXRwdXRWYWx1ZXMnXSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIHJlc1snb3V0cHV0Q292YXJpYW5jZSddXG4gICAgICAgICAgICAgID0gdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gJ3Byb2JsZW0gb2NjdXJlZCBkdXJpbmcgZmlsdGVyaW5nIDogJyArIGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdHNDYWxsYmFjaykge1xuICAgICAgcmVzdWx0c0NhbGxiYWNrKGVyciwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgLyBTRVRURVJTID09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKlxuICAgKiBMaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBsaWtlbGlob29kV2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICB9XG5cbiAgc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAgIHRoaXMuX3VwZGF0ZUxpa2VsaWhvb2RXaW5kb3coKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfdXBkYXRlTGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXS5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICB9XG4gICAgfSAgICBcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgZ2VuZXJhdGVkIGJ5IFhNTS5cbiAgICogSXQgaXMgbWFuZGF0b3J5IGZvciB0aGUgY2xhc3MgdG8gaGF2ZSBhIG1vZGVsIGluIG9yZGVyIHRvIGRvIGl0cyBqb2IuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXQgbW9kZWwoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQgbW9kZWwobW9kZWwpIHtcbiAgICB0aGlzLl9zZXRNb2RlbChtb2RlbCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3NldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gdGVzdCBpZiBtb2RlbCBpcyB2YWxpZCBoZXJlIChUT0RPIDogd3JpdGUgYSBiZXR0ZXIgdGVzdClcbiAgICBpZiAobW9kZWwubW9kZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICBjb25zdCBtID0gdGhpcy5fbW9kZWw7XG4gICAgICBjb25zdCBubW9kZWxzID0gbS5tb2RlbHMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMgPSB7XG4gICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGxpa2VsaWVzdDogLTEsXG4gICAgICAgIHNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIHJlZ3Jlc3Npb24gOlxuICAgICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGRpbU91dCA9IHBhcmFtcy5kaW1lbnNpb24gLSBwYXJhbXMuZGltZW5zaW9uX2lucHV0O1xuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMgPSBuZXcgQXJyYXkoZGltT3V0KTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlc1tpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dENvdmFyU2l6ZTtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmdWxsXG4gICAgICBpZiAobS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5jb3ZhcmlhbmNlX21vZGUgPT0gMCkge1xuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQgKiBkaW1PdXQ7XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkaWFnb25hbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2VbaV0gPSAwLjA7XG4gICAgICB9XG5cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5tb2RlbHM7IGkrKykge1xuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXMubGlrZWxpaG9vZF9idWZmZXJfaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzIGFyZSB1c2VkIGZvciByZWdyZXNzaW9uIDpcbiAgICAgICAgcmVzLmJldGEgPSBuZXcgQXJyYXkobS5tb2RlbHNbaV0uY29tcG9uZW50cy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzLmJldGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXMuYmV0YVtqXSA9IDEgLyByZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXMub3V0cHV0X3ZhbHVlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXMub3V0cHV0X2NvdmFyaWFuY2UgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gbm93IGFkZCB0aGlzIHNpbmdsZU1vZGVsUmVzdWx0cyBvYmplY3RcbiAgICAgICAgLy8gdG8gdGhlIGdsb2JhbCBtb2RlbFJlc3VsdHMgb2JqZWN0IDpcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2gocmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudGx5IGVzdGltYXRlZCBsaWtlbGllc3QgbGFiZWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxpa2VsaWVzdExhYmVsKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbFJlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwubW9kZWxzW3RoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBjbGFzc2VzIGNvbnRhaW5lZCBpbiB0aGUgbW9kZWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IG5iQ2xhc3NlcygpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpemUgb2YgdGhlIHJlZ3Jlc3Npb24gdmVjdG9yIGlmIG1vZGVsIGlzIGJpbW9kYWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlZ3Jlc3Npb25TaXplKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2hhcmVkX3BhcmFtZXRlcnMuZGltZW5zaW9uX2lucHV0O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR21tRGVjb2RlcjsiXX0=