'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _gmmUtils = require('../utils/gmm-utils');

var gmmUtils = _interopRequireWildcard(_gmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vectors in real-time
 * if the model was trained for regression, outputs an estimation
 */

var GmmDecoder = function () {

  /**
   * @param {String} windowSize - size of the likelihood smoothing window
   */
  function GmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, GmmDecoder);


    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this.model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter
     * @type {Object}
     */
    this.modelResults = undefined;

    /**
     * Size of the likelihood smoothing window
     * @type {Number}
     */
    this._likelihoodWindow = windowSize;
  }

  /**
   * @typedef GmmResults
   * @type {Object}
   * @property {string} likeliest - the likeliest model's label
   * @property {Array.number} likelihoods - the array of all models' normalized likelihoods
   * @property {?Array.number} outputValues - if the model was trained with regression, the estimated float vector output
   */

  /**
   * Callback handling estimation results
   * @callback resultsCallback
   * @param {String} err - description of a potential error
   * @param {GmmResults} res - object holding the estimation results
   */

  /**
   * The decoding function
   * @param {Array} observation - an input float vector to be estimated
   * @param {resultsCallback} resultsCallback - the callback handling the estimation results
   */


  (0, _createClass3.default)(GmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      if (this.model === undefined) {
        console.log("no model loaded");
        return;
      }

      var err = null;
      var res = null;

      try {
        gmmUtils.gmmFilter(observation, this.model, this.modelResults);

        var lklst = this.modelResults.likeliest > -1 ? this.model.models[this.modelResults.likeliest].label : 'unknown';
        var lklhds = this.modelResults.smoothed_normalized_likelihoods.slice(0);
        res = {
          likeliest: lklst,
          likelihoods: lklhds
        };

        // add regression results to global results if bimodal :
        if (this.model.shared_parameters.bimodal) {
          res.outputValues = this.modelResults.output_values.slice(0);
          // results.outputCovariance
          //     = this.modelResults.output_covariance.slice(0);
        }
      } catch (e) {
        err = 'problem occured during filtering : ' + e;
      }

      resultsCallback(err, res);
    }

    //=================== SETTERS =====================//

  }, {
    key: 'model',
    set: function set(model) {
      this.model = undefined;
      this.modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this.model = model;
        var m = this.model;
        var nmodels = m.models.length;
        this.modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          singleClassGmmModelResults: []
        };

        // the following variables are used for regression :

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this.modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this.modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        //------------------------------------------------------------- full
        if (m.configuration.default_parameters.covariance_mode == 0) {
          outCovarSize = dimOut * dimOut;
          //--------------------------------------------------------- diagonal
        } else {
          outCovarSize = dimOut;
        }
        this.modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this.modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this.modelResults.instant_likelihoods[_i2] = 0;
          this.modelResults.smoothed_log_likelihoods[_i2] = 0;
          this.modelResults.smoothed_likelihoods[_i2] = 0;
          this.modelResults.instant_normalized_likelihoods[_i2] = 0;
          this.modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var res = {
            instant_likelihood: 0,
            log_likelihood: 0
          };

          res.likelihood_buffer = new Array(this._likelihoodWindow);
          for (var j = 0; j < this._likelihoodWindow; j++) {
            res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
          }
          res.likelihood_buffer_index = 0;

          // the following variables are used for regression :

          res.beta = new Array(m.models[_i2].components.length);
          for (var _j = 0; _j < res.beta.length; _j++) {
            res.beta[_j] = 1 / res.beta.length;
          }
          res.output_values = this.modelResults.output_values.slice(0);
          res.output_covariance = this.modelResults.output_covariance.slice(0);

          // now add this singleModelResults object
          // to the global modelResults object :

          this.modelResults.singleClassGmmModelResults.push(res);
        }
      }
    },
    get: function get() {
      if (this.model !== undefined) {
        return JSON.fromString((0, _stringify2.default)(this.model));
      }
      return undefined;
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      if (this.model === undefined) return;
      var res = this.modelResults.singleClassModelResults;
      for (var i = 0; i < this.model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);
        for (var j = 0; j < this._likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    //=================== GETTERS =====================//

    ,
    get: function get() {
      return this._likelihoodWindow;
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this.modelResults !== undefined) {
        if (this.modelResults.likeliest > -1) {
          return this.model.models[this.modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }
  }, {
    key: 'nbClasses',
    get: function get() {
      if (this.model !== undefined) {
        return this.model.models.length;
      }
      return 0;
    }
  }]);
  return GmmDecoder;
}();

exports.default = GmmDecoder;
//# sourceMappingURL=data:application/json;base64,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SyxpQkFBcEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozt3QkF5QnVCO0FBQ3JCLGFBQU8sS0FBSyxpQkFBWjtBQUNEOzs7d0JBekJvQjtBQUNuQixVQUFHLEtBQUssWUFBTCxLQUFzQixTQUF6QixFQUFvQztBQUNsQyxZQUFHLEtBQUssWUFBTCxDQUFrQixTQUFsQixHQUE4QixDQUFDLENBQWxDLEVBQXFDO0FBQ25DLGlCQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsS0FBSyxZQUFMLENBQWtCLFNBQXBDLEVBQStDLEtBQXREO0FBQ0Q7QUFDRjtBQUNELGFBQU8sU0FBUDtBQUNEOzs7d0JBRWU7QUFDZCxVQUFHLEtBQUssS0FBTCxLQUFlLFNBQWxCLEVBQTZCO0FBQzNCLGVBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixNQUF6QjtBQUNEO0FBQ0QsYUFBTyxDQUFQO0FBQ0Q7Ozs7O2tCQTVMa0IsVSIsImZpbGUiOiJnbW0tZGVjb2Rlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGdtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2dtbS11dGlscyc7XG5cbi8qKlxuICogR01NIGRlY29kZXJcbiAqIGxvYWRzIGEgbW9kZWwgdHJhaW5lZCBieSB0aGUgWE1NIGxpYnJhcnkgYW5kIHByb2Nlc3NlcyBhbiBpbnB1dCBzdHJlYW0gb2YgZmxvYXQgdmVjdG9ycyBpbiByZWFsLXRpbWVcbiAqIGlmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCBmb3IgcmVncmVzc2lvbiwgb3V0cHV0cyBhbiBlc3RpbWF0aW9uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR21tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dTaXplIC0gc2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aW5kb3dTaXplID0gMSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbFJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3dcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSB3aW5kb3dTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIEdtbVJlc3VsdHNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGxpa2VsaWVzdCAtIHRoZSBsaWtlbGllc3QgbW9kZWwncyBsYWJlbFxuICAgKiBAcHJvcGVydHkge0FycmF5Lm51bWJlcn0gbGlrZWxpaG9vZHMgLSB0aGUgYXJyYXkgb2YgYWxsIG1vZGVscycgbm9ybWFsaXplZCBsaWtlbGlob29kc1xuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dFZhbHVlcyAtIGlmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoIHJlZ3Jlc3Npb24sIHRoZSBlc3RpbWF0ZWQgZmxvYXQgdmVjdG9yIG91dHB1dFxuICAgKi9cblxuICAvKipcbiAgICogQ2FsbGJhY2sgaGFuZGxpbmcgZXN0aW1hdGlvbiByZXN1bHRzXG4gICAqIEBjYWxsYmFjayByZXN1bHRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVyciAtIGRlc2NyaXB0aW9uIG9mIGEgcG90ZW50aWFsIGVycm9yXG4gICAqIEBwYXJhbSB7R21tUmVzdWx0c30gcmVzIC0gb2JqZWN0IGhvbGRpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0c1xuICAgKi9cblxuICAvKipcbiAgICogVGhlIGRlY29kaW5nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9ic2VydmF0aW9uIC0gYW4gaW5wdXQgZmxvYXQgdmVjdG9yIHRvIGJlIGVzdGltYXRlZFxuICAgKiBAcGFyYW0ge3Jlc3VsdHNDYWxsYmFja30gcmVzdWx0c0NhbGxiYWNrIC0gdGhlIGNhbGxiYWNrIGhhbmRsaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHNcbiAgICovXG4gIGZpbHRlcihvYnNlcnZhdGlvbiwgcmVzdWx0c0NhbGxiYWNrKSB7XG4gICAgaWYodGhpcy5tb2RlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm5vIG1vZGVsIGxvYWRlZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBnbW1VdGlscy5nbW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMubW9kZWwsIHRoaXMubW9kZWxSZXN1bHRzKTsgICAgICAgICBcblxuICAgICAgY29uc3QgbGtsc3QgPSAodGhpcy5tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpXG4gICAgICAgICAgICAgICAgICA/IHRoaXMubW9kZWwubW9kZWxzW3RoaXMubW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgIDogJ3Vua25vd24nO1xuICAgICAgY29uc3QgbGtsaGRzID0gdGhpcy5tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcy5zbGljZSgwKTtcbiAgICAgIHJlcyA9IHtcbiAgICAgICAgbGlrZWxpZXN0OiBsa2xzdCxcbiAgICAgICAgbGlrZWxpaG9vZHM6IGxrbGhkcyAgICAgICAgIFxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgcmVncmVzc2lvbiByZXN1bHRzIHRvIGdsb2JhbCByZXN1bHRzIGlmIGJpbW9kYWwgOlxuICAgICAgaWYodGhpcy5tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgIHJlcy5vdXRwdXRWYWx1ZXMgPSB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAvLyByZXN1bHRzLm91dHB1dENvdmFyaWFuY2VcbiAgICAgICAgLy8gICAgID0gdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gJ3Byb2JsZW0gb2NjdXJlZCBkdXJpbmcgZmlsdGVyaW5nIDogJyArIGU7XG4gICAgfVxuXG4gICAgcmVzdWx0c0NhbGxiYWNrKGVyciwgcmVzKTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PSBTRVRURVJTID09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgc2V0IG1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHRlc3QgaWYgbW9kZWwgaXMgdmFsaWQgaGVyZSAoVE9ETyA6IHdyaXRlIGEgYmV0dGVyIHRlc3QpXG4gICAgaWYobW9kZWwubW9kZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLm1vZGVsO1xuICAgICAgY29uc3Qgbm1vZGVscyA9IG0ubW9kZWxzLmxlbmd0aDtcbiAgICAgIHRoaXMubW9kZWxSZXN1bHRzID0ge1xuICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xvZ19saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBsaWtlbGllc3Q6IC0xLFxuICAgICAgICBzaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0czogW11cbiAgICAgIH07XG5cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzIGFyZSB1c2VkIGZvciByZWdyZXNzaW9uIDpcblxuICAgICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGRpbU91dCA9IHBhcmFtcy5kaW1lbnNpb24gLSBwYXJhbXMuZGltZW5zaW9uX2lucHV0O1xuICAgICAgdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcyA9IG5ldyBBcnJheShkaW1PdXQpO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXNbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRDb3ZhclNpemU7XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZnVsbFxuICAgICAgaWYobS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5jb3ZhcmlhbmNlX21vZGUgPT0gMCkge1xuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQgKiBkaW1PdXQ7XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkaWFnb25hbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZVtpXSA9IDAuMDtcbiAgICAgIH1cblxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbm1vZGVsczsgaSsrKSB7XG5cbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMuaW5zdGFudF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLnNtb290aGVkX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMuaW5zdGFudF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcl9pbmRleCA9IDA7XG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIHJlZ3Jlc3Npb24gOlxuXG4gICAgICAgIHJlcy5iZXRhID0gbmV3IEFycmF5KG0ubW9kZWxzW2ldLmNvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHJlcy5iZXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzLmJldGFbal0gPSAxIC8gcmVzLmJldGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5vdXRwdXRfdmFsdWVzID0gdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlcy5zbGljZSgwKTtcbiAgICAgICAgcmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gbm93IGFkZCB0aGlzIHNpbmdsZU1vZGVsUmVzdWx0cyBvYmplY3RcbiAgICAgICAgLy8gdG8gdGhlIGdsb2JhbCBtb2RlbFJlc3VsdHMgb2JqZWN0IDpcblxuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0cy5wdXNoKHJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAgIGlmKHRoaXMubW9kZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMubW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzTW9kZWxSZXN1bHRzO1xuICAgIGZvcihsZXQgaT0wOyBpPHRoaXMubW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICBmb3IobGV0IGo9MDsgajx0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09Ly9cblxuICBnZXQgbGlrZWxpZXN0TGFiZWwoKSB7XG4gICAgaWYodGhpcy5tb2RlbFJlc3VsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYodGhpcy5tb2RlbFJlc3VsdHMubGlrZWxpZXN0ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubW9kZWxzW3RoaXMubW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICBnZXQgbmJDbGFzc2VzKCkge1xuICAgIGlmKHRoaXMubW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWwubW9kZWxzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgbW9kZWwoKSB7XG4gICAgaWYodGhpcy5tb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gSlNPTi5mcm9tU3RyaW5nKEpTT04uc3RyaW5naWZ5KHRoaXMubW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldCBsaWtlbGlob29kV2luZG93KCkge1xuICAgIHJldHVybiB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICB9XG59Il19