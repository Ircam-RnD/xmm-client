'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _gmmUtils = require('../utils/gmm-utils');

var gmmUtils = _interopRequireWildcard(_gmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GMM decoder <br />
 * Loads a model trained by the XMM library and processes an input stream of float vectors in real-time.
 * If the model was trained for regression, outputs an estimation of the associated process.
 * @class
 */

var GmmDecoder = function () {

  /**
   * @param {Number} [windowSize=1] - Size of the likelihood smoothing window.
   */
  function GmmDecoder() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, GmmDecoder);


    /**
     * The model, as generated by XMM from a training data set.
     * @type {Object}
     * @private
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter.
     * @type {Object}
     * @private
     */
    this._modelResults = undefined;

    /**
     * Size of the likelihood smoothing window.
     * @type {Number}
     * @private
     */
    this._likelihoodWindow = windowSize;

    this._weights = [];
  }

  /**
   * Callback handling estimation results.
   * @callback gmmResultsCallback
   * @param {String} err - Description of a potential error.
   * @param {gmmResults} res - Object holding the estimation results.
   */

  /**
   * Results of the filtering process.
   * @typedef gmmResults
   * @type {Object}
   * @name gmmResults
   * @property {String} likeliest - The likeliest model's label.
   * @property {Number} likeliestIndex - The likeliest model's index
   * @property {Array.number} likelihoods - The array of all models' smoothed normalized likelihoods.
   * @property {?Array.number} outputValues - If the model was trained with regression, the estimated float vector output.
   * @property {?Array.number} outputCovariance - If the model was trained with regression, the output covariance matrix.
   */

  /**
   * The decoding function.
   * @param {Array} observation - An input float vector to be estimated.
   * @param {gmmResultsCallback} [resultsCallback=null] - The callback handling the estimation results.
   * @returns {gmmResults}
   */


  (0, _createClass3.default)(GmmDecoder, [{
    key: 'filter',
    value: function filter(observation) {
      var resultsCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var err = null;
      var res = null;

      if (!this._model) {
        err = 'no model loaded yet';
      } else {
        // try {
        gmmUtils.gmmFilter(observation, this._model, this._modelResults);

        // create results object from relevant modelResults values :
        var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : null;
        var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
        res = {
          likeliest: likeliest,
          likeliestIndex: this._modelResults.likeliest,
          likelihoods: likelihoods,
          outputValues: [],
          outputCovariance: []
        };

        // add regression results to global results if bimodal :
        if (this._model.shared_parameters.bimodal) {
          res['outputValues'] = this._modelResults.output_values.slice(0);
          res['outputCovariance'] = this._modelResults.output_covariance.slice(0);
        }
        // } catch (e) {
        //   err = 'problem occured during filtering : ' + e;
        // }
      }

      if (resultsCallback) {
        resultsCallback(err, res);
      }

      return res;
    }

    //=========================== GETTERS / SETTERS ============================//

    /***
     * Likelihood smoothing window size.
     * @type {Number}
     */
    // get likelihoodWindow() {
    //   return this._likelihoodWindow;
    // }

    // set likelihoodWindow(newWindowSize) {
    //   this._likelihoodWindow = newWindowSize;
    //   this._updateLikelihoodWindow();
    // }

    /**
     * Get the likelihood smoothing window size.
     * @returns {Number}
     */

  }, {
    key: 'getLikelihoodWindow',
    value: function getLikelihoodWindow() {
      return this._likelihoodWindow;
    }

    /**
     * Set the likelihood smoothing window size.
     * @param {Number} newWindowSize - the new window size.
     */

  }, {
    key: 'setLikelihoodWindow',
    value: function setLikelihoodWindow(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      this._updateLikelihoodWindow();
    }

    /** @private */

  }, {
    key: '_updateLikelihoodWindow',
    value: function _updateLikelihoodWindow() {
      if (this._model === undefined) return;

      var res = this._modelResults.singleClassGmmModelResults;

      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);

        for (var j = 0; j < this._likelihoodWindow; j++) {
          res[i].likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }
  }, {
    key: 'setWeights',
    value: function setWeights(newWeights) {
      if (!Array.isArray(newWeights)) {
        throw new Error('Weights must be an array');
      }

      this._weights = newWeights;
      this._updateWeights();
    }

    /** @private */

  }, {
    key: '_updateWeights',
    value: function _updateWeights() {
      if (this._model === undefined) return;

      var m = this._model;
      var params = m.shared_parameters;
      var dimIn = params.bimodal ? params.dimension_input : params.dimension;

      var w = this._weights.slice();

      if (w.length < dimIn) {
        var onesToAdd = dimIn - w.length;

        for (var i = 0; i < onesToAdd; i++) {
          w.push(1);
        }
      } else if (w.length > dimIn) {
        w.splice(dimIn - 1);
      }

      for (var _i = 0; _i < w.length; _i++) {
        w[_i] = Math.max(w[_i], 0);
      }

      for (var _i2 = 0; _i2 < m.models.length; _i2++) {
        for (var j = 0; j < m.models[_i2].components.length; j++) {
          m.models[_i2].components[j].weights = w;
        }
      }
    }

    /**
     * A valid XMM GMM model
     * @typedef xmmGmmModel
     * @type {Object}
     * @name xmmGmmModel
     * @property {String} TODO - LIST REAL GMM MODEL PROPERTIES HERE
     */

    /***
     * The model generated by XMM.
     * It is mandatory for the class to have a model in order to do its job.
     * @type {xmmGmmModel}
     */
    // get model() {
    //   return this.getModel();
    // }

    // set model(model) {
    //   this.setModel(model);
    // }

    /**
     * Get the actual XMM GMM model.
     * @returns {xmmGmmModel}
     */

  }, {
    key: 'getModel',
    value: function getModel() {
      if (this._model) {
        return JSON.parse((0, _stringify2.default)(this._model));
      }
      return undefined;
    }

    /**
     * Set the actual XMM GMM model.
     * @param {xmmGmmModel} model
     */

  }, {
    key: 'setModel',
    value: function setModel(model) {
      this._setModel(model);
    }

    /** @private */

  }, {
    key: '_setModel',
    value: function _setModel(model) {
      this._model = undefined;
      this._modelResults = undefined;

      if (!model) return;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;

        // adds user defined weights to the model (default [1, 1, ..., 1])
        this._updateWeights();

        var m = this._model;
        var nmodels = m.models.length;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          singleClassGmmModelResults: []
        };

        // the following variables are used for regression :
        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);

        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        //------------------------------------------------------------------- full
        if (m.configuration.default_parameters.covariance_mode == 0) {
          outCovarSize = dimOut * dimOut;
          //--------------------------------------------------------------- diagonal
        } else {
          outCovarSize = dimOut;
        }

        this._modelResults.output_covariance = new Array(outCovarSize);

        for (var _i3 = 0; _i3 < dimOut; _i3++) {
          this._modelResults.output_covariance[_i3] = 0.0;
        }

        for (var _i4 = 0; _i4 < nmodels; _i4++) {
          this._modelResults.instant_likelihoods[_i4] = 0;
          this._modelResults.smoothed_log_likelihoods[_i4] = 0;
          this._modelResults.smoothed_likelihoods[_i4] = 0;
          this._modelResults.instant_normalized_likelihoods[_i4] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i4] = 0;

          var res = {
            instant_likelihood: 0,
            log_likelihood: 0
          };

          res.likelihood_buffer = new Array(this._likelihoodWindow);

          for (var j = 0; j < this._likelihoodWindow; j++) {
            res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
          }

          res.likelihood_buffer_index = 0;

          // the following variables are used for regression :
          res.beta = new Array(m.models[_i4].components.length);

          for (var _j = 0; _j < res.beta.length; _j++) {
            res.beta[_j] = 1 / res.beta.length;
          }

          res.output_values = this._modelResults.output_values.slice(0);
          res.output_covariance = this._modelResults.output_covariance.slice(0);

          // now add this singleModelResults object
          // to the global modelResults object :
          this._modelResults.singleClassGmmModelResults.push(res);
        }
      }
    }

    /***
     * Currently estimated likeliest label.
     * @readonly
     * @type {String}
     */
    // get likeliestLabel() {
    //   return this.getLikeliestLabel();
    // }

    /**
     * Get the currently estimated likeliest label.
     * @returns {String}
     */

  }, {
    key: 'getLikeliestLabel',
    value: function getLikeliestLabel() {
      if (this._modelResults) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }

    /***
     * Number of classes contained in the model.
     * @readonly
     * @type {Number}
     */
    // get nbClasses() {
    //   return this.getNumberOfClasses();
    // }

    /**
     * Get the total number of classes the model was trained with.
     * @returns {Number}
     */

  }, {
    key: 'getNumberOfClasses',
    value: function getNumberOfClasses() {
      if (this._model) {
        return this._model.models.length;
      }
      return 0;
    }

    /***
     * Size of the regression vector if model is bimodal.
     * @readonly
     * @type {Number}
     */
    // get regressionSize() {
    //   return this.getRegressionVectorSize();
    // }

    /**
     * Get the output dimension of the model (size of a regression vector).
     * @returns {Number}
     */

  }, {
    key: 'getRegressionVectorSize',
    value: function getRegressionVectorSize() {
      if (this._model) {
        var params = this._model.shared_parameters;
        return params['bimodal'] ? params['dimension'] - params['dimension_input'] : 0;
      }
      return 0;
    }
  }]);
  return GmmDecoder;
}();

;

exports.default = GmmDecoder;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImdtbS1kZWNvZGVyLmpzIl0sIm5hbWVzIjpbImdtbVV0aWxzIiwiR21tRGVjb2RlciIsIndpbmRvd1NpemUiLCJfbW9kZWwiLCJ1bmRlZmluZWQiLCJfbW9kZWxSZXN1bHRzIiwiX2xpa2VsaWhvb2RXaW5kb3ciLCJfd2VpZ2h0cyIsIm9ic2VydmF0aW9uIiwicmVzdWx0c0NhbGxiYWNrIiwiZXJyIiwicmVzIiwiZ21tRmlsdGVyIiwibGlrZWxpZXN0IiwibW9kZWxzIiwibGFiZWwiLCJsaWtlbGlob29kcyIsInNtb290aGVkX25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMiLCJzbGljZSIsImxpa2VsaWVzdEluZGV4Iiwib3V0cHV0VmFsdWVzIiwib3V0cHV0Q292YXJpYW5jZSIsInNoYXJlZF9wYXJhbWV0ZXJzIiwiYmltb2RhbCIsIm91dHB1dF92YWx1ZXMiLCJvdXRwdXRfY292YXJpYW5jZSIsIm5ld1dpbmRvd1NpemUiLCJfdXBkYXRlTGlrZWxpaG9vZFdpbmRvdyIsInNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzIiwiaSIsImxlbmd0aCIsImxpa2VsaWhvb2RfYnVmZmVyIiwiQXJyYXkiLCJqIiwibmV3V2VpZ2h0cyIsImlzQXJyYXkiLCJFcnJvciIsIl91cGRhdGVXZWlnaHRzIiwibSIsInBhcmFtcyIsImRpbUluIiwiZGltZW5zaW9uX2lucHV0IiwiZGltZW5zaW9uIiwidyIsIm9uZXNUb0FkZCIsInB1c2giLCJzcGxpY2UiLCJNYXRoIiwibWF4IiwiY29tcG9uZW50cyIsIndlaWdodHMiLCJKU09OIiwicGFyc2UiLCJtb2RlbCIsIl9zZXRNb2RlbCIsIm5tb2RlbHMiLCJpbnN0YW50X2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzIiwic21vb3RoZWRfbGlrZWxpaG9vZHMiLCJpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHMiLCJkaW1PdXQiLCJvdXRDb3ZhclNpemUiLCJjb25maWd1cmF0aW9uIiwiZGVmYXVsdF9wYXJhbWV0ZXJzIiwiY292YXJpYW5jZV9tb2RlIiwiaW5zdGFudF9saWtlbGlob29kIiwibG9nX2xpa2VsaWhvb2QiLCJsaWtlbGlob29kX2J1ZmZlcl9pbmRleCIsImJldGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztJQUFZQSxROzs7Ozs7QUFFWjs7Ozs7OztJQU9NQyxVOztBQUVKOzs7QUFHQSx3QkFBNEI7QUFBQSxRQUFoQkMsVUFBZ0IsdUVBQUgsQ0FBRztBQUFBOzs7QUFFMUI7Ozs7O0FBS0EsU0FBS0MsTUFBTCxHQUFjQyxTQUFkOztBQUVBOzs7OztBQUtBLFNBQUtDLGFBQUwsR0FBcUJELFNBQXJCOztBQUVBOzs7OztBQUtBLFNBQUtFLGlCQUFMLEdBQXlCSixVQUF6Qjs7QUFFQSxTQUFLSyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7O0FBWUE7Ozs7Ozs7Ozs7MkJBTU9DLFcsRUFBcUM7QUFBQSxVQUF4QkMsZUFBd0IsdUVBQU4sSUFBTTs7QUFDMUMsVUFBSUMsTUFBTSxJQUFWO0FBQ0EsVUFBSUMsTUFBTSxJQUFWOztBQUVBLFVBQUcsQ0FBQyxLQUFLUixNQUFULEVBQWlCO0FBQ2ZPLGNBQU0scUJBQU47QUFDRCxPQUZELE1BRU87QUFDTDtBQUNFVixpQkFBU1ksU0FBVCxDQUFtQkosV0FBbkIsRUFBZ0MsS0FBS0wsTUFBckMsRUFBNkMsS0FBS0UsYUFBbEQ7O0FBRUE7QUFDQSxZQUFNUSxZQUFhLEtBQUtSLGFBQUwsQ0FBbUJRLFNBQW5CLEdBQStCLENBQUMsQ0FBakMsR0FDQSxLQUFLVixNQUFMLENBQVlXLE1BQVosQ0FBbUIsS0FBS1QsYUFBTCxDQUFtQlEsU0FBdEMsRUFBaURFLEtBRGpELEdBRUEsSUFGbEI7QUFHQSxZQUFNQyxjQUFjLEtBQUtYLGFBQUwsQ0FBbUJZLCtCQUFuQixDQUFtREMsS0FBbkQsQ0FBeUQsQ0FBekQsQ0FBcEI7QUFDQVAsY0FBTTtBQUNKRSxxQkFBV0EsU0FEUDtBQUVKTSwwQkFBZ0IsS0FB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VXRpbHMgZnJvbSAnLi4vdXRpbHMvZ21tLXV0aWxzJztcblxuLyoqXG4gKiBHTU0gZGVjb2RlciA8YnIgLz5cbiAqIExvYWRzIGEgbW9kZWwgdHJhaW5lZCBieSB0aGUgWE1NIGxpYnJhcnkgYW5kIHByb2Nlc3NlcyBhbiBpbnB1dCBzdHJlYW0gb2YgZmxvYXQgdmVjdG9ycyBpbiByZWFsLXRpbWUuXG4gKiBJZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgZm9yIHJlZ3Jlc3Npb24sIG91dHB1dHMgYW4gZXN0aW1hdGlvbiBvZiB0aGUgYXNzb2NpYXRlZCBwcm9jZXNzLlxuICogQGNsYXNzXG4gKi9cblxuY2xhc3MgR21tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2luZG93U2l6ZT0xXSAtIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHdpbmRvd1NpemUgPSAxKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwsIGFzIGdlbmVyYXRlZCBieSBYTU0gZnJvbSBhIHRyYWluaW5nIGRhdGEgc2V0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93LlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gd2luZG93U2l6ZTtcblxuICAgIHRoaXMuX3dlaWdodHMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqIEBjYWxsYmFjayBnbW1SZXN1bHRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVyciAtIERlc2NyaXB0aW9uIG9mIGEgcG90ZW50aWFsIGVycm9yLlxuICAgKiBAcGFyYW0ge2dtbVJlc3VsdHN9IHJlcyAtIE9iamVjdCBob2xkaW5nIHRoZSBlc3RpbWF0aW9uIHJlc3VsdHMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXN1bHRzIG9mIHRoZSBmaWx0ZXJpbmcgcHJvY2Vzcy5cbiAgICogQHR5cGVkZWYgZ21tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAbmFtZSBnbW1SZXN1bHRzXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsaWtlbGllc3QgLSBUaGUgbGlrZWxpZXN0IG1vZGVsJ3MgbGFiZWwuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsaWtlbGllc3RJbmRleCAtIFRoZSBsaWtlbGllc3QgbW9kZWwncyBpbmRleFxuICAgKiBAcHJvcGVydHkge0FycmF5Lm51bWJlcn0gbGlrZWxpaG9vZHMgLSBUaGUgYXJyYXkgb2YgYWxsIG1vZGVscycgc21vb3RoZWQgbm9ybWFsaXplZCBsaWtlbGlob29kcy5cbiAgICogQHByb3BlcnR5IHs/QXJyYXkubnVtYmVyfSBvdXRwdXRWYWx1ZXMgLSBJZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgd2l0aCByZWdyZXNzaW9uLCB0aGUgZXN0aW1hdGVkIGZsb2F0IHZlY3RvciBvdXRwdXQuXG4gICAqIEBwcm9wZXJ0eSB7P0FycmF5Lm51bWJlcn0gb3V0cHV0Q292YXJpYW5jZSAtIElmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoIHJlZ3Jlc3Npb24sIHRoZSBvdXRwdXQgY292YXJpYW5jZSBtYXRyaXguXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZGVjb2RpbmcgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9ic2VydmF0aW9uIC0gQW4gaW5wdXQgZmxvYXQgdmVjdG9yIHRvIGJlIGVzdGltYXRlZC5cbiAgICogQHBhcmFtIHtnbW1SZXN1bHRzQ2FsbGJhY2t9IFtyZXN1bHRzQ2FsbGJhY2s9bnVsbF0gLSBUaGUgY2FsbGJhY2sgaGFuZGxpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICogQHJldHVybnMge2dtbVJlc3VsdHN9XG4gICAqL1xuICBmaWx0ZXIob2JzZXJ2YXRpb24sIHJlc3VsdHNDYWxsYmFjayA9IG51bGwpIHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIGlmKCF0aGlzLl9tb2RlbCkge1xuICAgICAgZXJyID0gJ25vIG1vZGVsIGxvYWRlZCB5ZXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cnkge1xuICAgICAgICBnbW1VdGlscy5nbW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMuX21vZGVsLCB0aGlzLl9tb2RlbFJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXN1bHRzIG9iamVjdCBmcm9tIHJlbGV2YW50IG1vZGVsUmVzdWx0cyB2YWx1ZXMgOlxuICAgICAgICBjb25zdCBsaWtlbGllc3QgPSAodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgY29uc3QgbGlrZWxpaG9vZHMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcy5zbGljZSgwKTtcbiAgICAgICAgcmVzID0ge1xuICAgICAgICAgIGxpa2VsaWVzdDogbGlrZWxpZXN0LFxuICAgICAgICAgIGxpa2VsaWVzdEluZGV4OiB0aGlzLl9tb2RlbFJlc3VsdHMubGlrZWxpZXN0LFxuICAgICAgICAgIGxpa2VsaWhvb2RzOiBsaWtlbGlob29kcyxcbiAgICAgICAgICBvdXRwdXRWYWx1ZXM6IFtdLFxuICAgICAgICAgIG91dHB1dENvdmFyaWFuY2U6IFtdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCByZWdyZXNzaW9uIHJlc3VsdHMgdG8gZ2xvYmFsIHJlc3VsdHMgaWYgYmltb2RhbCA6XG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgICAgcmVzWydvdXRwdXRWYWx1ZXMnXSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIHJlc1snb3V0cHV0Q292YXJpYW5jZSddXG4gICAgICAgICAgICAgID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAvLyB9IGNhdGNoIChlKSB7XG4gICAgICAvLyAgIGVyciA9ICdwcm9ibGVtIG9jY3VyZWQgZHVyaW5nIGZpbHRlcmluZyA6ICcgKyBlO1xuICAgICAgLy8gfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRzQ2FsbGJhY2spIHtcbiAgICAgIHJlc3VsdHNDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgLyBTRVRURVJTID09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIC8qKipcbiAgICogTGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93IHNpemUuXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICAvLyBnZXQgbGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgLy8gfVxuXG4gIC8vIHNldCBsaWtlbGlob29kV2luZG93KG5ld1dpbmRvd1NpemUpIHtcbiAgLy8gICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gbmV3V2luZG93U2l6ZTtcbiAgLy8gICB0aGlzLl91cGRhdGVMaWtlbGlob29kV2luZG93KCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldExpa2VsaWhvb2RXaW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld1dpbmRvd1NpemUgLSB0aGUgbmV3IHdpbmRvdyBzaXplLlxuICAgKi9cbiAgc2V0TGlrZWxpaG9vZFdpbmRvdyhuZXdXaW5kb3dTaXplKSB7XG4gICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IG5ld1dpbmRvd1NpemU7XG4gICAgdGhpcy5fdXBkYXRlTGlrZWxpaG9vZFdpbmRvdygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF91cGRhdGVMaWtlbGlob29kV2luZG93KCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBjb25zdCByZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cpO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXJbal0gPSAxIC8gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRXZWlnaHRzKG5ld1dlaWdodHMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3V2VpZ2h0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2VpZ2h0cyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fd2VpZ2h0cyA9IG5ld1dlaWdodHM7XG4gICAgdGhpcy5fdXBkYXRlV2VpZ2h0cygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF91cGRhdGVXZWlnaHRzKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICBjb25zdCBtID0gdGhpcy5fbW9kZWw7XG4gICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICBjb25zdCBkaW1JbiA9IHBhcmFtcy5iaW1vZGFsID8gcGFyYW1zLmRpbWVuc2lvbl9pbnB1dCA6IHBhcmFtcy5kaW1lbnNpb247XG5cbiAgICBjb25zdCB3ID0gdGhpcy5fd2VpZ2h0cy5zbGljZSgpO1xuXG4gICAgaWYgKHcubGVuZ3RoIDwgZGltSW4pIHtcbiAgICAgIGNvbnN0IG9uZXNUb0FkZCA9IGRpbUluIC0gdy5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lc1RvQWRkOyBpKyspIHtcbiAgICAgICAgdy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAody5sZW5ndGggPiBkaW1Jbikge1xuICAgICAgdy5zcGxpY2UoZGltSW4gLSAxKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdbaV0gPSBNYXRoLm1heCh3W2ldLCAwKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG0ubW9kZWxzW2ldLmNvbXBvbmVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbS5tb2RlbHNbaV0uY29tcG9uZW50c1tqXS53ZWlnaHRzID0gdztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBIHZhbGlkIFhNTSBHTU0gbW9kZWxcbiAgICogQHR5cGVkZWYgeG1tR21tTW9kZWxcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQG5hbWUgeG1tR21tTW9kZWxcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFRPRE8gLSBMSVNUIFJFQUwgR01NIE1PREVMIFBST1BFUlRJRVMgSEVSRVxuICAgKi9cblxuICAvKioqXG4gICAqIFRoZSBtb2RlbCBnZW5lcmF0ZWQgYnkgWE1NLlxuICAgKiBJdCBpcyBtYW5kYXRvcnkgZm9yIHRoZSBjbGFzcyB0byBoYXZlIGEgbW9kZWwgaW4gb3JkZXIgdG8gZG8gaXRzIGpvYi5cbiAgICogQHR5cGUge3htbUdtbU1vZGVsfVxuICAgKi9cbiAgLy8gZ2V0IG1vZGVsKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmdldE1vZGVsKCk7XG4gIC8vIH1cblxuICAvLyBzZXQgbW9kZWwobW9kZWwpIHtcbiAgLy8gICB0aGlzLnNldE1vZGVsKG1vZGVsKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGFjdHVhbCBYTU0gR01NIG1vZGVsLlxuICAgKiBAcmV0dXJucyB7eG1tR21tTW9kZWx9XG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhY3R1YWwgWE1NIEdNTSBtb2RlbC5cbiAgICogQHBhcmFtIHt4bW1HbW1Nb2RlbH0gbW9kZWxcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5fc2V0TW9kZWwobW9kZWwpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9zZXRNb2RlbChtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIGlmICghbW9kZWwpIHJldHVybjtcblxuICAgIC8vIHRlc3QgaWYgbW9kZWwgaXMgdmFsaWQgaGVyZSAoVE9ETyA6IHdyaXRlIGEgYmV0dGVyIHRlc3QpXG4gICAgaWYgKG1vZGVsLm1vZGVscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuXG4gICAgICAvLyBhZGRzIHVzZXIgZGVmaW5lZCB3ZWlnaHRzIHRvIHRoZSBtb2RlbCAoZGVmYXVsdCBbMSwgMSwgLi4uLCAxXSlcbiAgICAgIHRoaXMuX3VwZGF0ZVdlaWdodHMoKTtcblxuICAgICAgY29uc3QgbSA9IHRoaXMuX21vZGVsO1xuICAgICAgY29uc3Qgbm1vZGVscyA9IG0ubW9kZWxzLmxlbmd0aDtcblxuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzID0ge1xuICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xvZ19saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBsaWtlbGllc3Q6IC0xLFxuICAgICAgICBzaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0czogW11cbiAgICAgIH07XG5cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzIGFyZSB1c2VkIGZvciByZWdyZXNzaW9uIDpcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG0uc2hhcmVkX3BhcmFtZXRlcnM7XG4gICAgICBjb25zdCBkaW1PdXQgPSBwYXJhbXMuZGltZW5zaW9uIC0gcGFyYW1zLmRpbWVuc2lvbl9pbnB1dDtcbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzID0gbmV3IEFycmF5KGRpbU91dCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXNbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRDb3ZhclNpemU7XG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZnVsbFxuICAgICAgaWYgKG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuY292YXJpYW5jZV9tb2RlID09IDApIHtcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0ICogZGltT3V0O1xuICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGlhZ29uYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dENvdmFyU2l6ZSA9IGRpbU91dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlID0gbmV3IEFycmF5KG91dENvdmFyU2l6ZSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlW2ldID0gMC4wO1xuICAgICAgfVxuXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBubW9kZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLmluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzW2ldID0gMDtcblxuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdzsgaisrKSB7XG4gICAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubGlrZWxpaG9vZF9idWZmZXJfaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzIGFyZSB1c2VkIGZvciByZWdyZXNzaW9uIDpcbiAgICAgICAgcmVzLmJldGEgPSBuZXcgQXJyYXkobS5tb2RlbHNbaV0uY29tcG9uZW50cy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzLmJldGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXMuYmV0YVtqXSA9IDEgLyByZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXMub3V0cHV0X3ZhbHVlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXMub3V0cHV0X2NvdmFyaWFuY2UgPSB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2Uuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gbm93IGFkZCB0aGlzIHNpbmdsZU1vZGVsUmVzdWx0cyBvYmplY3RcbiAgICAgICAgLy8gdG8gdGhlIGdsb2JhbCBtb2RlbFJlc3VsdHMgb2JqZWN0IDpcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2gocmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKioqXG4gICAqIEN1cnJlbnRseSBlc3RpbWF0ZWQgbGlrZWxpZXN0IGxhYmVsLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIC8vIGdldCBsaWtlbGllc3RMYWJlbCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRMaWtlbGllc3RMYWJlbCgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudGx5IGVzdGltYXRlZCBsaWtlbGllc3QgbGFiZWwuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRMaWtlbGllc3RMYWJlbCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWxSZXN1bHRzKSB7XG4gICAgICBpZiAodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cblxuICAvKioqXG4gICAqIE51bWJlciBvZiBjbGFzc2VzIGNvbnRhaW5lZCBpbiB0aGUgbW9kZWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgLy8gZ2V0IG5iQ2xhc3NlcygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXROdW1iZXJPZkNsYXNzZXMoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBjbGFzc2VzIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCB3aXRoLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0TnVtYmVyT2ZDbGFzc2VzKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqKlxuICAgKiBTaXplIG9mIHRoZSByZWdyZXNzaW9uIHZlY3RvciBpZiBtb2RlbCBpcyBiaW1vZGFsLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIC8vIGdldCByZWdyZXNzaW9uU2l6ZSgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRSZWdyZXNzaW9uVmVjdG9yU2l6ZSgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb3V0cHV0IGRpbWVuc2lvbiBvZiB0aGUgbW9kZWwgKHNpemUgb2YgYSByZWdyZXNzaW9uIHZlY3RvcikuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWdyZXNzaW9uVmVjdG9yU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX21vZGVsLnNoYXJlZF9wYXJhbWV0ZXJzO1xuICAgICAgcmV0dXJuIHBhcmFtc1snYmltb2RhbCddXG4gICAgICAgICAgID8gcGFyYW1zWydkaW1lbnNpb24nXSAtIHBhcmFtc1snZGltZW5zaW9uX2lucHV0J11cbiAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR21tRGVjb2RlcjsiXX0=