'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _gmmUtils = require('../utils/gmm-utils');

var gmmUtils = _interopRequireWildcard(_gmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vectors in real-time
 * if the model was trained for regression, outputs an estimation
 */

var GmmDecoder = function () {

  /**
   * @param {String} windowSize - size of the likelihood smoothing window
   */
  function GmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, GmmDecoder);


    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this.model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter
     * @type {Object}
     */
    this.modelResults = undefined;

    /**
     * Size of the likelihood smoothing window
     * @type {Number}
     */
    this.likelihoodWindow = windowSize;
  }

  /**
   * @typedef GmmResults
   * @type {Object}
   * @property {string} likeliest - the likeliest model's label
   * @property {Array.number} likelihoods - the array of all models' normalized likelihoods
   * @property {?Array.number} outputValues - if the model was trained with regression, the estimated float vector output
   */

  /**
   * Callback handling estimation results
   * @callback resultsCallback
   * @param {String} err - description of a potential error
   * @param {GmmResults} res - object holding the estimation results
   */

  /**
   * The decoding function
   * @param {Array} observation - an input float vector to be estimated
   * @param {resultsCallback} resultsCallback - the callback handling the estimation results
   */


  (0, _createClass3.default)(GmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      if (this.model === undefined) {
        console.log("no model loaded");
        return;
      }

      var err = null;
      var res = null;

      try {
        gmmUtils.gmmFilter(observation, this.model, this.modelResults);

        var lklst = this.modelResults.likeliest > -1 ? this.model.models[this.modelResults.likeliest].label : 'unknown';
        var lklhds = this.modelResults.smoothed_normalized_likelihoods.slice(0);
        res = {
          likeliest: lklst,
          likelihoods: lklhds
        };

        // add regression results to global results if bimodal :
        if (this.model.shared_parameters.bimodal) {
          res.outputValues = this.modelResults.output_values.slice(0);
          // results.outputCovariance
          //     = this.modelResults.output_covariance.slice(0);
        }
      } catch (e) {
        err = 'problem occured during filtering : ' + e;
      }

      resultsCallback(err, res);
    }

    //=================== SETTERS =====================//

  }, {
    key: 'model',
    set: function set(model) {
      this.model = undefined;
      this.modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this.model = model;
        var m = this.model;
        var nmodels = m.models.length;
        this.modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          singleClassGmmModelResults: []
        };

        // the following variables are used for regression :

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this.modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this.modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        //------------------------------------------------------------- full
        if (m.configuration.default_parameters.covariance_mode == 0) {
          outCovarSize = dimOut * dimOut;
          //--------------------------------------------------------- diagonal
        } else {
          outCovarSize = dimOut;
        }
        this.modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this.modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this.modelResults.instant_likelihoods[_i2] = 0;
          this.modelResults.smoothed_log_likelihoods[_i2] = 0;
          this.modelResults.smoothed_likelihoods[_i2] = 0;
          this.modelResults.instant_normalized_likelihoods[_i2] = 0;
          this.modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var res = {
            instant_likelihood: 0,
            log_likelihood: 0
          };

          res.likelihood_buffer = new Array(this.likelihoodWindow);
          for (var j = 0; j < this.likelihoodWindow; j++) {
            res.likelihood_buffer[j] = 1 / this.likelihoodWindow;
          }
          res.likelihood_buffer_index = 0;

          // the following variables are used for regression :

          res.beta = new Array(m.models[_i2].components.length);
          for (var _j = 0; _j < res.beta.length; _j++) {
            res.beta[_j] = 1 / res.beta.length;
          }
          res.output_values = this.modelResults.output_values.slice(0);
          res.output_covariance = this.modelResults.output_covariance.slice(0);

          // now add this singleModelResults object
          // to the global modelResults object :

          this.modelResults.singleClassGmmModelResults.push(res);
        }
      }
    },
    get: function get() {
      if (this.model !== undefined) {
        return JSON.fromString((0, _stringify2.default)(this.model));
      }
      return undefined;
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this.likelihoodWindow = newWindowSize;
      if (this.model === undefined) return;
      var res = this.modelResults.singleClassModelResults;
      for (var i = 0; i < this.model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this.likelihoodWindow);
        for (var j = 0; j < this.likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this.likelihoodWindow;
        }
      }
    }

    //=================== GETTERS =====================//

    ,
    get: function get() {
      return this.likelihoodWindow;
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this.modelResults !== undefined) {
        if (this.modelResults.likeliest > -1) {
          return this.model.models[this.modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }
  }, {
    key: 'nbClasses',
    get: function get() {
      if (this.model !== undefined) {
        return this.model.models.length;
      }
      return 0;
    }
  }]);
  return GmmDecoder;
}();

exports.default = GmmDecoder;
//# sourceMappingURL=data:application/json;base64,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SyxnQkFBcEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozt3QkF5QnVCO0FBQ3JCLGFBQU8sS0FBSyxnQkFBWjtBQUNEOzs7d0JBekJvQjtBQUNuQixVQUFHLEtBQUssWUFBTCxLQUFzQixTQUF6QixFQUFvQztBQUNsQyxZQUFHLEtBQUssWUFBTCxDQUFrQixTQUFsQixHQUE4QixDQUFDLENBQWxDLEVBQXFDO0FBQ25DLGlCQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsS0FBSyxZQUFMLENBQWtCLFNBQXBDLEVBQStDLEtBQXREO0FBQ0Q7QUFDRjtBQUNELGFBQU8sU0FBUDtBQUNEOzs7d0JBRWU7QUFDZCxVQUFHLEtBQUssS0FBTCxLQUFlLFNBQWxCLEVBQTZCO0FBQzNCLGVBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixNQUF6QjtBQUNEO0FBQ0QsYUFBTyxDQUFQO0FBQ0Q7Ozs7O2tCQTVMa0IsVSIsImZpbGUiOiJnbW0tZGVjb2Rlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGdtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2dtbS11dGlscyc7XG5cbi8qKlxuICogR01NIGRlY29kZXJcbiAqIGxvYWRzIGEgbW9kZWwgdHJhaW5lZCBieSB0aGUgWE1NIGxpYnJhcnkgYW5kIHByb2Nlc3NlcyBhbiBpbnB1dCBzdHJlYW0gb2YgZmxvYXQgdmVjdG9ycyBpbiByZWFsLXRpbWVcbiAqIGlmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCBmb3IgcmVncmVzc2lvbiwgb3V0cHV0cyBhbiBlc3RpbWF0aW9uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR21tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dTaXplIC0gc2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aW5kb3dTaXplID0gMSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5tb2RlbFJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBsaWtlbGlob29kIHNtb290aGluZyB3aW5kb3dcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGlrZWxpaG9vZFdpbmRvdyA9IHdpbmRvd1NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgR21tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGlrZWxpZXN0IC0gdGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSBsaWtlbGlob29kcyAtIHRoZSBhcnJheSBvZiBhbGwgbW9kZWxzJyBub3JtYWxpemVkIGxpa2VsaWhvb2RzXG4gICAqIEBwcm9wZXJ0eSB7P0FycmF5Lm51bWJlcn0gb3V0cHV0VmFsdWVzIC0gaWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIGVzdGltYXRlZCBmbG9hdCB2ZWN0b3Igb3V0cHV0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHNcbiAgICogQGNhbGxiYWNrIHJlc3VsdHNDYWxsYmFja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyIC0gZGVzY3JpcHRpb24gb2YgYSBwb3RlbnRpYWwgZXJyb3JcbiAgICogQHBhcmFtIHtHbW1SZXN1bHRzfSByZXMgLSBvYmplY3QgaG9sZGluZyB0aGUgZXN0aW1hdGlvbiByZXN1bHRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZGVjb2RpbmcgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gb2JzZXJ2YXRpb24gLSBhbiBpbnB1dCBmbG9hdCB2ZWN0b3IgdG8gYmUgZXN0aW1hdGVkXG4gICAqIEBwYXJhbSB7cmVzdWx0c0NhbGxiYWNrfSByZXN1bHRzQ2FsbGJhY2sgLSB0aGUgY2FsbGJhY2sgaGFuZGxpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0c1xuICAgKi9cbiAgZmlsdGVyKG9ic2VydmF0aW9uLCByZXN1bHRzQ2FsbGJhY2spIHtcbiAgICBpZih0aGlzLm1vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwibm8gbW9kZWwgbG9hZGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGdtbVV0aWxzLmdtbUZpbHRlcihvYnNlcnZhdGlvbiwgdGhpcy5tb2RlbCwgdGhpcy5tb2RlbFJlc3VsdHMpOyAgICAgICAgIFxuXG4gICAgICBjb25zdCBsa2xzdCA9ICh0aGlzLm1vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSlcbiAgICAgICAgICAgICAgICAgID8gdGhpcy5tb2RlbC5tb2RlbHNbdGhpcy5tb2RlbFJlc3VsdHMubGlrZWxpZXN0XS5sYWJlbFxuICAgICAgICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICBjb25zdCBsa2xoZHMgPSB0aGlzLm1vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzLnNsaWNlKDApO1xuICAgICAgcmVzID0ge1xuICAgICAgICBsaWtlbGllc3Q6IGxrbHN0LFxuICAgICAgICBsaWtlbGlob29kczogbGtsaGRzICAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCByZWdyZXNzaW9uIHJlc3VsdHMgdG8gZ2xvYmFsIHJlc3VsdHMgaWYgYmltb2RhbCA6XG4gICAgICBpZih0aGlzLm1vZGVsLnNoYXJlZF9wYXJhbWV0ZXJzLmJpbW9kYWwpIHtcbiAgICAgICAgcmVzLm91dHB1dFZhbHVlcyA9IHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIC8vIHJlc3VsdHMub3V0cHV0Q292YXJpYW5jZVxuICAgICAgICAvLyAgICAgPSB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSAncHJvYmxlbSBvY2N1cmVkIGR1cmluZyBmaWx0ZXJpbmcgOiAnICsgZTtcbiAgICB9XG5cbiAgICByZXN1bHRzQ2FsbGJhY2soZXJyLCByZXMpO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09IFNFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09Ly9cblxuICBzZXQgbW9kZWwobW9kZWwpIHtcbiAgICB0aGlzLm1vZGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gdGVzdCBpZiBtb2RlbCBpcyB2YWxpZCBoZXJlIChUT0RPIDogd3JpdGUgYSBiZXR0ZXIgdGVzdClcbiAgICBpZihtb2RlbC5tb2RlbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgY29uc3QgbSA9IHRoaXMubW9kZWw7XG4gICAgICBjb25zdCBubW9kZWxzID0gbS5tb2RlbHMubGVuZ3RoO1xuICAgICAgdGhpcy5tb2RlbFJlc3VsdHMgPSB7XG4gICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGxpa2VsaWVzdDogLTEsXG4gICAgICAgIHNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzOiBbXVxuICAgICAgfTtcblxuICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIHJlZ3Jlc3Npb24gOlxuXG4gICAgICBjb25zdCBwYXJhbXMgPSBtLnNoYXJlZF9wYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgZGltT3V0ID0gcGFyYW1zLmRpbWVuc2lvbiAtIHBhcmFtcy5kaW1lbnNpb25faW5wdXQ7XG4gICAgICB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzID0gbmV3IEFycmF5KGRpbU91dCk7XG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGltT3V0OyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlc1tpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dENvdmFyU2l6ZTtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmdWxsXG4gICAgICBpZihtLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmNvdmFyaWFuY2VfbW9kZSA9PSAwKSB7XG4gICAgICAgIG91dENvdmFyU2l6ZSA9IGRpbU91dCAqIGRpbU91dDtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRpYWdvbmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZSA9IG5ldyBBcnJheShvdXRDb3ZhclNpemUpO1xuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlW2ldID0gMC4wO1xuICAgICAgfVxuXG5cbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBubW9kZWxzOyBpKyspIHtcblxuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMuc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5tb2RlbFJlc3VsdHMuc21vb3RoZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLm1vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzW2ldID0gMDtcblxuICAgICAgICBjb25zdCByZXMgPSB7XG4gICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMubGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICAgIGZvcihsZXQgaiA9IDA7IGogPCB0aGlzLmxpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLmxpa2VsaWhvb2RXaW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyX2luZGV4ID0gMDtcblxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHZhcmlhYmxlcyBhcmUgdXNlZCBmb3IgcmVncmVzc2lvbiA6XG5cbiAgICAgICAgcmVzLmJldGEgPSBuZXcgQXJyYXkobS5tb2RlbHNbaV0uY29tcG9uZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IobGV0IGogPSAwOyBqIDwgcmVzLmJldGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXMuYmV0YVtqXSA9IDEgLyByZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLm91dHB1dF92YWx1ZXMgPSB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICByZXMub3V0cHV0X2NvdmFyaWFuY2UgPSB0aGlzLm1vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBub3cgYWRkIHRoaXMgc2luZ2xlTW9kZWxSZXN1bHRzIG9iamVjdFxuICAgICAgICAvLyB0byB0aGUgZ2xvYmFsIG1vZGVsUmVzdWx0cyBvYmplY3QgOlxuXG4gICAgICAgIHRoaXMubW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2gocmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXQgbGlrZWxpaG9vZFdpbmRvdyhuZXdXaW5kb3dTaXplKSB7XG4gICAgdGhpcy5saWtlbGlob29kV2luZG93ID0gbmV3V2luZG93U2l6ZTtcbiAgICBpZih0aGlzLm1vZGVsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCByZXMgPSB0aGlzLm1vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc01vZGVsUmVzdWx0cztcbiAgICBmb3IobGV0IGk9MDsgaTx0aGlzLm1vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMubGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICBmb3IobGV0IGo9MDsgajx0aGlzLmxpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICByZXMubGlrZWxpaG9vZF9idWZmZXJbal0gPSAxIC8gdGhpcy5saWtlbGlob29kV2luZG93O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PSBHRVRURVJTID09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgZ2V0IGxpa2VsaWVzdExhYmVsKCkge1xuICAgIGlmKHRoaXMubW9kZWxSZXN1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmKHRoaXMubW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm1vZGVsc1t0aGlzLm1vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG5cbiAgZ2V0IG5iQ2xhc3NlcygpIHtcbiAgICBpZih0aGlzLm1vZGVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLm1vZGVscy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0IG1vZGVsKCkge1xuICAgIGlmKHRoaXMubW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEpTT04uZnJvbVN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLm1vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXQgbGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5saWtlbGlob29kV2luZG93O1xuICB9XG59Il19