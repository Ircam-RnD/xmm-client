'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _gmmUtils = require('../utils/gmm-utils');

var gmmUtils = _interopRequireWildcard(_gmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * GMM decoder
 * loads a model trained by the XMM library and processes an input stream of float vectors in real-time
 * if the model was trained for regression, outputs an estimation
 */

var GmmDecoder = function () {

  /**
   * @param {String} windowSize - size of the likelihood smoothing window
   */
  function GmmDecoder() {
    var windowSize = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
    (0, _classCallCheck3.default)(this, GmmDecoder);


    /**
     * The model, as generated by XMM from a training data set
     * @type {Object}
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter
     * @type {Object}
     */
    this._modelResults = undefined;

    /**
     * Size of the likelihood smoothing window
     * @type {Number}
     */
    this._likelihoodWindow = windowSize;
  }

  /**
   * @typedef GmmResults
   * @type {Object}
   * @property {string} likeliest - the likeliest model's label
   * @property {Array.number} likelihoods - the array of all models' normalized likelihoods
   * @property {?Array.number} outputValues - if the model was trained with regression, the estimated float vector output
   */

  /**
   * Callback handling estimation results
   * @callback resultsCallback
   * @param {String} err - description of a potential error
   * @param {GmmResults} res - object holding the estimation results
   */

  /**
   * The decoding function
   * @param {Array} observation - an input float vector to be estimated
   * @param {resultsCallback} resultsCallback - the callback handling the estimation results
   */


  (0, _createClass3.default)(GmmDecoder, [{
    key: 'filter',
    value: function filter(observation, resultsCallback) {
      var err = null;
      var res = null;

      if (this._model === undefined) {
        console.log("no model loaded");
        return;
      } else {
        try {
          gmmUtils.gmmFilter(observation, this._model, this._modelResults);

          var lklst = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var lklhds = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: lklst,
            likelihoods: lklhds
          };

          // add regression results to global results if bimodal :
          if (this._model.shared_parameters.bimodal) {
            res.outputValues = this._modelResults.output_values.slice(0);
            // results.outputCovariance
            //     = this.modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      resultsCallback(err, res);
    }

    //=================== SETTERS =====================//

  }, {
    key: 'model',
    set: function set(model) {
      this._model = undefined;
      this._modelResults = undefined;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;
        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          singleClassGmmModelResults: []
        };

        // the following variables are used for regression :

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        //------------------------------------------------------------- full
        if (m.configuration.default_parameters.covariance_mode == 0) {
          outCovarSize = dimOut * dimOut;
          //--------------------------------------------------------- diagonal
        } else {
          outCovarSize = dimOut;
        }
        this._modelResults.output_covariance = new Array(outCovarSize);
        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {

          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var res = {
            instant_likelihood: 0,
            log_likelihood: 0
          };

          res.likelihood_buffer = new Array(this._likelihoodWindow);
          for (var j = 0; j < this._likelihoodWindow; j++) {
            res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
          }
          res.likelihood_buffer_index = 0;

          // the following variables are used for regression :

          res.beta = new Array(m.models[_i2].components.length);
          for (var _j = 0; _j < res.beta.length; _j++) {
            res.beta[_j] = 1 / res.beta.length;
          }
          res.output_values = this._modelResults.output_values.slice(0);
          res.output_covariance = this._modelResults.output_covariance.slice(0);

          // now add this singleModelResults object
          // to the global modelResults object :

          this._modelResults.singleClassGmmModelResults.push(res);
        }
      }
    },
    get: function get() {
      if (this._model !== undefined) {
        return JSON.fromString((0, _stringify2.default)(this._model));
      }
      return undefined;
    }
  }, {
    key: 'likelihoodWindow',
    set: function set(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      if (this._model === undefined) return;
      var res = this._modelResults.singleClassModelResults;
      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);
        for (var j = 0; j < this._likelihoodWindow; j++) {
          res.likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    //=================== GETTERS =====================//

    ,
    get: function get() {
      return this._likelihoodWindow;
    }
  }, {
    key: 'likeliestLabel',
    get: function get() {
      if (this._modelResults !== undefined) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }
  }, {
    key: 'nbClasses',
    get: function get() {
      if (this._model !== undefined) {
        return this._model.models.length;
      }
      return 0;
    }
  }]);
  return GmmDecoder;
}();

exports.default = GmmDecoder;
//# sourceMappingURL=data:application/json;base64,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Q0FBdEIsSUFBMkIsSUFBSSxLQUFLLGlCQUFwQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7O3dCQXlCdUI7QUFDckIsYUFBTyxLQUFLLGlCQUFaO0FBQ0Q7Ozt3QkF6Qm9CO0FBQ25CLFVBQUcsS0FBSyxhQUFMLEtBQXVCLFNBQTFCLEVBQXFDO0FBQ25DLFlBQUcsS0FBSyxhQUFMLENBQW1CLFNBQW5CLEdBQStCLENBQUMsQ0FBbkMsRUFBc0M7QUFDcEMsaUJBQU8sS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUFLLGFBQUwsQ0FBbUIsU0FBdEMsRUFBaUQsS0FBeEQ7QUFDRDtBQUNGO0FBQ0QsYUFBTyxTQUFQO0FBQ0Q7Ozt3QkFFZTtBQUNkLFVBQUcsS0FBSyxNQUFMLEtBQWdCLFNBQW5CLEVBQThCO0FBQzVCLGVBQU8sS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixNQUExQjtBQUNEO0FBQ0QsYUFBTyxDQUFQO0FBQ0Q7Ozs7O2tCQTVMa0IsVSIsImZpbGUiOiJnbW0tZGVjb2Rlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGdtbVV0aWxzIGZyb20gJy4uL3V0aWxzL2dtbS11dGlscyc7XG5cbi8qKlxuICogR01NIGRlY29kZXJcbiAqIGxvYWRzIGEgbW9kZWwgdHJhaW5lZCBieSB0aGUgWE1NIGxpYnJhcnkgYW5kIHByb2Nlc3NlcyBhbiBpbnB1dCBzdHJlYW0gb2YgZmxvYXQgdmVjdG9ycyBpbiByZWFsLXRpbWVcbiAqIGlmIHRoZSBtb2RlbCB3YXMgdHJhaW5lZCBmb3IgcmVncmVzc2lvbiwgb3V0cHV0cyBhbiBlc3RpbWF0aW9uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR21tRGVjb2RlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB3aW5kb3dTaXplIC0gc2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3aW5kb3dTaXplID0gMSkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsLCBhcyBnZW5lcmF0ZWQgYnkgWE1NIGZyb20gYSB0cmFpbmluZyBkYXRhIHNldFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwgcmVzdWx0cywgY29udGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBpbiBmaWx0ZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvd1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IHdpbmRvd1NpemU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgR21tUmVzdWx0c1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGlrZWxpZXN0IC0gdGhlIGxpa2VsaWVzdCBtb2RlbCdzIGxhYmVsXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXkubnVtYmVyfSBsaWtlbGlob29kcyAtIHRoZSBhcnJheSBvZiBhbGwgbW9kZWxzJyBub3JtYWxpemVkIGxpa2VsaWhvb2RzXG4gICAqIEBwcm9wZXJ0eSB7P0FycmF5Lm51bWJlcn0gb3V0cHV0VmFsdWVzIC0gaWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIGVzdGltYXRlZCBmbG9hdCB2ZWN0b3Igb3V0cHV0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBoYW5kbGluZyBlc3RpbWF0aW9uIHJlc3VsdHNcbiAgICogQGNhbGxiYWNrIHJlc3VsdHNDYWxsYmFja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyIC0gZGVzY3JpcHRpb24gb2YgYSBwb3RlbnRpYWwgZXJyb3JcbiAgICogQHBhcmFtIHtHbW1SZXN1bHRzfSByZXMgLSBvYmplY3QgaG9sZGluZyB0aGUgZXN0aW1hdGlvbiByZXN1bHRzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgZGVjb2RpbmcgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gb2JzZXJ2YXRpb24gLSBhbiBpbnB1dCBmbG9hdCB2ZWN0b3IgdG8gYmUgZXN0aW1hdGVkXG4gICAqIEBwYXJhbSB7cmVzdWx0c0NhbGxiYWNrfSByZXN1bHRzQ2FsbGJhY2sgLSB0aGUgY2FsbGJhY2sgaGFuZGxpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0c1xuICAgKi9cbiAgZmlsdGVyKG9ic2VydmF0aW9uLCByZXN1bHRzQ2FsbGJhY2spIHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gbnVsbDtcblxuICAgIGlmKHRoaXMuX21vZGVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwibm8gbW9kZWwgbG9hZGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBnbW1VdGlscy5nbW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMuX21vZGVsLCB0aGlzLl9tb2RlbFJlc3VsdHMpOyAgICAgICAgIFxuXG4gICAgICAgIGNvbnN0IGxrbHN0ID0gKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgOiAndW5rbm93bic7XG4gICAgICAgIGNvbnN0IGxrbGhkcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzLnNsaWNlKDApO1xuICAgICAgICByZXMgPSB7XG4gICAgICAgICAgbGlrZWxpZXN0OiBsa2xzdCxcbiAgICAgICAgICBsaWtlbGlob29kczogbGtsaGRzICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVncmVzc2lvbiByZXN1bHRzIHRvIGdsb2JhbCByZXN1bHRzIGlmIGJpbW9kYWwgOlxuICAgICAgICBpZih0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgICAgcmVzLm91dHB1dFZhbHVlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIC8vIHJlc3VsdHMub3V0cHV0Q292YXJpYW5jZVxuICAgICAgICAgIC8vICAgICA9IHRoaXMubW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9ICdwcm9ibGVtIG9jY3VyZWQgZHVyaW5nIGZpbHRlcmluZyA6ICcgKyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdHNDYWxsYmFjayhlcnIsIHJlcyk7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT0gU0VUVEVSUyA9PT09PT09PT09PT09PT09PT09PT0vL1xuXG4gIHNldCBtb2RlbChtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21vZGVsUmVzdWx0cyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHRlc3QgaWYgbW9kZWwgaXMgdmFsaWQgaGVyZSAoVE9ETyA6IHdyaXRlIGEgYmV0dGVyIHRlc3QpXG4gICAgaWYobW9kZWwubW9kZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICBjb25zdCBtID0gdGhpcy5fbW9kZWw7XG4gICAgICBjb25zdCBubW9kZWxzID0gbS5tb2RlbHMubGVuZ3RoO1xuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzID0ge1xuICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xvZ19saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBpbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBsaWtlbGllc3Q6IC0xLFxuICAgICAgICBzaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0czogW11cbiAgICAgIH07XG5cbiAgICAgIC8vIHRoZSBmb2xsb3dpbmcgdmFyaWFibGVzIGFyZSB1c2VkIGZvciByZWdyZXNzaW9uIDpcblxuICAgICAgY29uc3QgcGFyYW1zID0gbS5zaGFyZWRfcGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGRpbU91dCA9IHBhcmFtcy5kaW1lbnNpb24gLSBwYXJhbXMuZGltZW5zaW9uX2lucHV0O1xuICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMgPSBuZXcgQXJyYXkoZGltT3V0KTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X3ZhbHVlc1tpXSA9IDAuMDtcbiAgICAgIH1cblxuICAgICAgbGV0IG91dENvdmFyU2l6ZTtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBmdWxsXG4gICAgICBpZihtLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmNvdmFyaWFuY2VfbW9kZSA9PSAwKSB7XG4gICAgICAgIG91dENvdmFyU2l6ZSA9IGRpbU91dCAqIGRpbU91dDtcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRpYWdvbmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRDb3ZhclNpemUgPSBkaW1PdXQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcbiAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2VbaV0gPSAwLjA7XG4gICAgICB9XG5cblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG5tb2RlbHM7IGkrKykge1xuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZDogMCxcbiAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlciA9IG5ldyBBcnJheSh0aGlzLl9saWtlbGlob29kV2luZG93KTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcltqXSA9IDEgLyB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAgICAgICB9XG4gICAgICAgIHJlcy5saWtlbGlob29kX2J1ZmZlcl9pbmRleCA9IDA7XG5cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyB2YXJpYWJsZXMgYXJlIHVzZWQgZm9yIHJlZ3Jlc3Npb24gOlxuXG4gICAgICAgIHJlcy5iZXRhID0gbmV3IEFycmF5KG0ubW9kZWxzW2ldLmNvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yKGxldCBqID0gMDsgaiA8IHJlcy5iZXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzLmJldGFbal0gPSAxIC8gcmVzLmJldGEubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5vdXRwdXRfdmFsdWVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIHJlcy5vdXRwdXRfY292YXJpYW5jZSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBub3cgYWRkIHRoaXMgc2luZ2xlTW9kZWxSZXN1bHRzIG9iamVjdFxuICAgICAgICAvLyB0byB0aGUgZ2xvYmFsIG1vZGVsUmVzdWx0cyBvYmplY3QgOlxuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0dtbU1vZGVsUmVzdWx0cy5wdXNoKHJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAgIGlmKHRoaXMuX21vZGVsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBjb25zdCByZXMgPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NNb2RlbFJlc3VsdHM7XG4gICAgZm9yKGxldCBpPTA7IGk8dGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXIgPSBuZXcgQXJyYXkodGhpcy5fbGlrZWxpaG9vZFdpbmRvdyk7XG4gICAgICBmb3IobGV0IGo9MDsgajx0aGlzLl9saWtlbGlob29kV2luZG93OyBqKyspIHtcbiAgICAgICAgcmVzLmxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMSAvIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09IEdFVFRFUlMgPT09PT09PT09PT09PT09PT09PT09Ly9cblxuICBnZXQgbGlrZWxpZXN0TGFiZWwoKSB7XG4gICAgaWYodGhpcy5fbW9kZWxSZXN1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwubW9kZWxzW3RoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3Vua25vd24nO1xuICB9XG5cbiAgZ2V0IG5iQ2xhc3NlcygpIHtcbiAgICBpZih0aGlzLl9tb2RlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXQgbW9kZWwoKSB7XG4gICAgaWYodGhpcy5fbW9kZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIEpTT04uZnJvbVN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLl9tb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0IGxpa2VsaWhvb2RXaW5kb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7XG4gIH1cbn0iXX0=